var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Enzyme]\nOrder = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Enzyme]\nOrder = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Enzyme]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#Enzyme.Active","page":"API","title":"Enzyme.Active","text":"Active(x)\n\nMark a function argument x of autodiff as active, Enzyme will auto-differentiate in respect Active arguments.\n\nnote: Note\nEnzyme gradients with respect to integer values are zero. Active will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.Annotation","page":"API","title":"Enzyme.Annotation","text":"abstract type Annotation{T}\n\nAbstract type for autodiff function argument wrappers like Const, Active and Duplicated.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.BatchDuplicated","page":"API","title":"Enzyme.BatchDuplicated","text":"BatchDuplicated(x, ∂f_∂xs)\n\nLike Duplicated, except contains several shadows to compute derivatives for all at once. Argument ∂f_∂xs should be a tuple of the several values of type x.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.BatchDuplicatedNoNeed","page":"API","title":"Enzyme.BatchDuplicatedNoNeed","text":"BatchDuplicatedNoNeed(x, ∂f_∂xs)\n\nLike DuplicatedNoNeed, except contains several shadows to compute derivatives for all at once. Argument ∂f_∂xs should be a tuple of the several values of type x.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.Const","page":"API","title":"Enzyme.Const","text":"Const(x)\n\nMark a function argument x of autodiff as constant, Enzyme will not auto-differentiate in respect Const arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.Duplicated","page":"API","title":"Enzyme.Duplicated","text":"Duplicated(x, ∂f_∂x)\n\nMark a function argument x of autodiff as duplicated, Enzyme will auto-differentiate in respect to such arguments, with dx acting as an accumulator for gradients (so partial f  partial x will be added to) ∂f_∂x.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.DuplicatedNoNeed","page":"API","title":"Enzyme.DuplicatedNoNeed","text":"DuplicatedNoNeed(x, ∂f_∂x)\n\nLike Duplicated, except also specifies that Enzyme may avoid computing the original result and only compute the derivative values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.ForwardMode","page":"API","title":"Enzyme.ForwardMode","text":"struct Forward <: Mode\n\nForward mode differentiation\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.Mode","page":"API","title":"Enzyme.Mode","text":"abstract type Mode\n\nAbstract type for what differentiation mode will be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.ReverseMode","page":"API","title":"Enzyme.ReverseMode","text":"struct Reverse <: Mode\n\nReverse mode differentiation\n\n\n\n\n\n","category":"type"},{"location":"api/#Enzyme.autodiff-Union{Tuple{A}, Tuple{F}, Tuple{Enzyme.ForwardMode, F, Type{A}, Vararg{Any}}} where {F, A<:Enzyme.Annotation}","page":"API","title":"Enzyme.autodiff","text":"autodiff(::ForwardMode, f, Activity, args...)\n\nAuto-differentiate function f at arguments args using forward mode.\n\nargs may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in a Duplicated or similar argument. Non-annotated arguments will automatically be treated as Const. Unlike reverse mode in autodiff, Active arguments are not allowed here, since all \n\nActivity is the Activity of the return value, it may be:\n\nConst if the return is not to be differentiated with respect to\nDuplicated, if the return is being differentiated with respect to and both the original value and the derivative return are desired\nDuplicatedNoNeed, if the return is being differentiated with respect to and only the derivative return is desired.\n\nExample returning both original return and derivative:\n\na = 4.2\nb = [2.2, 3.3]; ∂f_∂b = zero(b)\nc = 55; d = 9\n\nf(x) = x*x\nres, ∂f_∂x = autodiff(Forward, f, Duplicated, Duplicated(3.14, 1.0))\n\n# output\n\n(9.8596, 6.28)\n\nExample returning just the derivative:\n\na = 4.2\nb = [2.2, 3.3]; ∂f_∂b = zero(b)\nc = 55; d = 9\n\nf(x) = x*x\n∂f_∂x = autodiff(Forward, f, DuplicatedNoNeed, Duplicated(3.14, 1.0))\n\n# output\n\n(6.28,)\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.autodiff-Union{Tuple{A}, Tuple{F}, Tuple{Enzyme.ReverseMode, F, Type{A}, Vararg{Any}}} where {F, A<:Enzyme.Annotation}","page":"API","title":"Enzyme.autodiff","text":"autodiff(::ReverseMode, f, Activity, args...)\n\nAuto-differentiate function f at arguments args using reverse mode.\n\nLimitations:\n\nf may only return a Real (of a built-in/primitive type) or nothing, not an array, struct, BigFloat, etc. To handle vector-valued return types, use a mutating f! that returns nothing and stores it's return value in one of the arguments, which must be wrapped in a Duplicated.\n\nargs may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in an Active (for immutable arguments like primitive types and structs thereof) or Duplicated (for mutable arguments like arrays, Refs and structs thereof). Non-annotated arguments will automatically be treated as Const.\n\nActivity is the Activity of the return value, it may be Const or Active.\n\nExample:\n\na = 4.2\nb = [2.2, 3.3]; ∂f_∂b = zero(b)\nc = 55; d = 9\n\nf(a, b, c, d) = a * √(b[1]^2 + b[2]^2) + c^2 * d^2\n∂f_∂a, ∂f_∂d = autodiff(Reverse, f, Active, Active(a), Duplicated(b, ∂f_∂b), c, Active(d))\n\n# output\n\n(3.966106403010388, 54450.0)\n\nhere, autodiff returns a tuple (partial fpartial a partial fpartial d), while partial fpartial b will be added to ∂f_∂b (but not returned). c will be treated as Const(c).\n\nnote: Note\nEnzyme gradients with respect to integer values are zero. Active will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.autodiff-Union{Tuple{F}, Tuple{Enzyme.Mode, F, Vararg{Any}}} where F","page":"API","title":"Enzyme.autodiff","text":"autodiff(mode::Mode, f, args...)\nautodiff(f, mode::Mode, args...)\n\nLike autodiff but will try to guess the activity of the return value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.autodiff_deferred-Union{Tuple{A}, Tuple{F}, Tuple{F, Type{A}, Vararg{Any}}} where {F, A<:Enzyme.Annotation}","page":"API","title":"Enzyme.autodiff_deferred","text":"autodiff_deferred(f, Activity, args...)\n\nSame as autodiff but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.autodiff_deferred-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F","page":"API","title":"Enzyme.autodiff_deferred","text":"autodiff_deferred(f, args...)\n\nLike autodiff_deferred but will try to guess the activity of the return value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.fwddiff_deferred-Union{Tuple{A}, Tuple{F}, Tuple{F, Type{A}, Vararg{Any}}} where {F, A<:Enzyme.Annotation}","page":"API","title":"Enzyme.fwddiff_deferred","text":"fwddiff_deferred(f, Activity, args...)\n\nSame as autodiff(::ForwardMode, ...) but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.fwddiff_deferred-Union{Tuple{F}, Tuple{F, Vararg{Any}}} where F","page":"API","title":"Enzyme.fwddiff_deferred","text":"fwddiff_deferred(f, args...)\n\nLike fwddiff_deferred but will try to guess the activity of the return value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.gradient!-Tuple{Enzyme.ReverseMode, Any, Any, Any}","page":"API","title":"Enzyme.gradient!","text":"gradient!(::ReverseMode, dx, f, x)\n\nCompute the gradient of an array-input function f using reverse mode, storing the derivative result in an existing array dx.\n\nExample:\n\nf(x) = x[1]*x[2]\n\ndx = [0.0, 0.0]\ngradient!(Reverse, dx, f, [2.0, 3.0])\n\n# output\n\n2-element Vector{Float64}:\n 3.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.gradient-Tuple{Enzyme.ForwardMode, Any, Any}","page":"API","title":"Enzyme.gradient","text":"gradient(::ForwardMode, f, x; shadow=onehot(x))\n\nCompute the gradient of an array-input function f using forward mode. The optional keyword argument shadow is a vector of one-hot vectors of type x which are used to forward-propagate into the return. For performance reasons, this should be computed once, outside the call to gradient, rather than within this call.\n\nExample:\n\nf(x) = x[1]*x[2]\n\ngrad = gradient(Forward, f, [2.0, 3.0])\n\n# output\n\n(3.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.gradient-Tuple{Enzyme.ReverseMode, Any, Any}","page":"API","title":"Enzyme.gradient","text":"gradient(::ReverseMode, f, x)\n\nCompute the gradient of an array-input function f using reverse mode. This will allocate and return new array with the gradient result.\n\nExample:\n\nf(x) = x[1]*x[2]\n\ngrad = gradient(Reverse, f, [2.0, 3.0])\n\n# output\n\n2-element Vector{Float64}:\n 3.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.gradient-Union{Tuple{chunk}, Tuple{Enzyme.ForwardMode, Any, Any, Val{chunk}}} where chunk","page":"API","title":"Enzyme.gradient","text":"gradient(::ForwardMode, f, x, ::Val{chunk}; shadow=onehot(x))\n\nCompute the gradient of an array-input function f using vector forward mode. Like gradient, except it uses a chunk size of chunk to compute chunk derivatives in a single call.\n\nExample:\n\nf(x) = x[1]*x[2]\n\ngrad = gradient(Forward, f, [2.0, 3.0], Val(2))\n\n# output\n\n(3.0, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.jacobian-Tuple{Enzyme.ForwardMode, Vararg{Any}}","page":"API","title":"Enzyme.jacobian","text":"jacobian(::ForwardMode, f, x; shadow=onehot(x))\njacobian(::ForwardMode, f, x, ::Val{chunk}; shadow=onehot(x))\n\nCompute the jacobian of an array-input function f using (potentially vector) forward mode. This is a simple rename of the gradient function, and all relevant arguments apply here.\n\nExample:\n\nf(x) = [x[1]*x[2], x[2]]\n\ngrad = jacobian(Forward, f, [2.0, 3.0])\n\n# output\n\n2×2 Matrix{Float64}:\n 3.0  2.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Enzyme.jacobian-Union{Tuple{n_out_val}, Tuple{chunk}, Tuple{Enzyme.ReverseMode, Any, Any, Val{n_out_val}, Val{chunk}}} where {chunk, n_out_val}","page":"API","title":"Enzyme.jacobian","text":"jacobian(::ReverseMode, f, x, ::Val{num_outs}, ::Val{chunk})\n\nCompute the jacobian of an array-input function f using (potentially vector) reverse mode. The chunk argument denotes the chunk size to use and num_outs denotes the number of outputs f will return in an array.\n\nExample:\n\nf(x) = [x[1]*x[2], x[2]]\n\ngrad = jacobian(Reverse, f, [2.0, 3.0], Val(2))\n\n# output\n\n2×2 Matrix{Float64}:\n 3.0  2.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"pullbacks/#Implementing-pullbacks","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"","category":"section"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"Enzyme's autodiff function can only handle functions with scalar output. To implement pullbacks (back-propagation of gradients/tangents) for array-valued functions, use a mutating function that returns nothing and stores it's result in one of the arguments, which must be passed wrapped in a Duplicated.","category":"page"},{"location":"pullbacks/#Example","page":"Implementing pullbacks","title":"Example","text":"","category":"section"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"Given a function mymul! that performs the equivalent of R = A * B for matrices A and B, and given a gradient (tangent) ∂z_∂R, we can compute ∂z_∂A and ∂z_∂B like this:","category":"page"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"using Enzyme\n\nfunction mymul!(R, A, B)\n    @assert axes(A,2) == axes(B,1)\n    @inbounds @simd for i in eachindex(R)\n        R[i] = 0\n    end\n    @inbounds for j in axes(B, 2), i in axes(A, 1)\n        @inbounds @simd for k in axes(A,2)\n            R[i,j] += A[i,k] * B[k,j]\n        end\n    end\n    nothing\nend\n\n\nA = rand(5, 3)\nB = rand(3, 7)\n\nR = zeros(size(A,1), size(B,2))\n∂z_∂R = rand(size(R)...)  # Some gradient/tangent passed to us\n\n∂z_∂A = zero(A)\n∂z_∂B = zero(B)\n\nEnzyme.autodiff(mymul!, Const, Duplicated(R, ∂z_∂R), Duplicated(A, ∂z_∂A), Duplicated(B, ∂z_∂B))","category":"page"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"Now we have:","category":"page"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"R ≈ A * B            &&\n∂z_∂A ≈ ∂z_∂R * B'   &&  # equivalent to Zygote.pullback(*, A, B)[2](∂z_∂R)[1]\n∂z_∂B ≈ A' * ∂z_∂R       # equivalent to Zygote.pullback(*, A, B)[2](∂z_∂R)[2]","category":"page"},{"location":"pullbacks/","page":"Implementing pullbacks","title":"Implementing pullbacks","text":"Note that the result of the backpropagation is added to ∂z_∂A and ∂z_∂B, they act as accumulators for gradient information.","category":"page"},{"location":"dev_docs/#Enzyme-developer-documentation","page":"For developers","title":"Enzyme developer documentation","text":"","category":"section"},{"location":"dev_docs/#Development-of-Enzyme-and-Enzyme.jl-together","page":"For developers","title":"Development of Enzyme and Enzyme.jl together","text":"","category":"section"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"Normally Enzyme.jl downloads and install Enzyme for the user automatically since Enzyme needs to be built against Julia bundeled LLVM. In case that you are making updates to Enzyme and want to test them against Enzyme.jl the instructions below should help you get started.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"Start Julia in your development copy of Enzyme.jl","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"~/s/Enzyme (master)> julia --project=.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"Then create a development copy of Enzyme_jll and activate it within.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"julia> using Enzyme_jll\njulia> Enzyme_jll.dev_jll()\n[ Info: Enzyme_jll dev'ed out to ${JULIA_PKG_DEVDIR}/Enzyme_jll with pre-populated override directory\n(Enzyme) pkg> dev Enzyme_jll\nPath `${JULIA_PKG_DEVDIR}/Enzyme_jll` exists and looks like the correct package. Using existing path.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"After restarting Julia:","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"julia> Enzyme_jll.dev_jll()\njulia> Enzyme_jll.libEnzyme_path\n\"${JULIA_PKG_DEVDIR}/Enzyme_jll/override/lib/LLVMEnzyme-9.so\"","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"On your machine ${JULIA_PKG_DEVDIR} most likely corresponds to ~/.julia/dev. Now we can inspect \"${JULIA_PKG_DEVDIR}/Enzyme_jll/override/lib and see that there is a copy of LLVMEnzyme-9.so, which we can replace with a symbolic link or a copy of a version of Enzyme.","category":"page"},{"location":"dev_docs/#Building-Enzyme-against-Julia's-LLVM.","page":"For developers","title":"Building Enzyme against Julia's LLVM.","text":"","category":"section"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"Depending on how you installed Julia the LLVM Julia is using will be different.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"Download from julialang.org (Recommended)\nManual build on your machine\nUses a pre-built Julia from your system vendor (Not recommended)","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"To check what LLVM Julia is using use:","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"julia> Base.libllvm_version_string\n\"9.0.1jl\"","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"If the LLVM version ends in a jl you a likely using the private LLVM.","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"In your source checkout of Enzyme:","category":"page"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"mkdir build-jl\ncd build-jl","category":"page"},{"location":"dev_docs/#Prebuilt-binary-from-julialang.org","page":"For developers","title":"Prebuilt binary from julialang.org","text":"","category":"section"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"LLVM_MAJOR_VER=`julia -e \"print(Base.libllvm_version.major)\"`\njulia -e \"using Pkg; pkg\\\"add LLVM_full_jll@${LLVM_MAJOR_VER}\\\"\"\nLLVM_DIR=`julia -e \"using LLVM_full_jll; print(LLVM_full_jll.artifact_dir)\"`\necho \"LLVM_DIR=$LLVM_DIR\"\ncmake ../enzyme/ -G Ninja -DENZYME_EXTERNAL_SHARED_LIB=ON -DLLVM_DIR=${LLVM_DIR} -DLLVM_EXTERNAL_LIT=${LLVM_DIR}/tools/lit/lit.py","category":"page"},{"location":"dev_docs/#Manual-build-of-Julia","page":"For developers","title":"Manual build of Julia","text":"","category":"section"},{"location":"dev_docs/","page":"For developers","title":"For developers","text":"cmake ../enzyme/ -G Ninja -DENZYME_EXTERNAL_SHARED_LIB=ON -DLLVM_DIR=${PATH_TO_BUILDDIR_OF_JULIA}/usr/lib/cmake/llvm/","category":"page"},{"location":"internal_api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"note: Note\nThis is the documentation of Enzymes's internal API. The internal API is not subject to semantic versioning and may change at any time and without deprecation.","category":"page"},{"location":"internal_api/","page":"Internal API","title":"Internal API","text":"Modules = [Enzyme.Compiler]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"internal_api/#Enzyme.Compiler.fspec-Tuple{Any, Any}","page":"Internal API","title":"Enzyme.Compiler.fspec","text":"Create the FunctionSpec pair, and lookup the primal return type.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Enzyme","category":"page"},{"location":"#Enzyme","page":"Home","title":"Enzyme","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Enzyme.jl, the Julia bindings for Enzyme.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enzyme performs automatic differentiation (AD) of statically analyzable LLVM. It is highly-efficient and its ability perform AD on optimized code allows Enzyme to meet or exceed the performance of state-of-the-art AD tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enzyme.jl can be installed in the usual way Julia packages are installed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Enzyme","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Enzyme binary dependencies will be installed automatically via Julia's binary actifact system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Enzyme.jl API revolves around the function autodiff, see it's documentation for details and a usage example. Also see Implementing pullbacks on how to use Enzyme.jl to implement back-propagation for functions with non-scalar results.","category":"page"},{"location":"#Caveats-/-Known-issues","page":"Home","title":"Caveats / Known-issues","text":"","category":"section"},{"location":"#CUDA.jl-support","page":"Home","title":"CUDA.jl support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CUDA.jl is only support on Julia v1.7.0 and onwards. On 1.6 attempting to differentiate CUDA kernel functions, will not use device overloads correctly and thus return fundamentally wrong results.","category":"page"}]
}
