<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Enzyme.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://enzyme.mit.edu/julia/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="https://plausible.io/js/plausible.js" data-domain="enzyme.mit.edu" defer></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Enzyme.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Enzyme.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/box/">Box model</a></li><li><a class="tocitem" href="../generated/autodiff/">AutoDiff API</a></li><li><a class="tocitem" href="../generated/custom_rule/">Custom rules</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types-and-constants"><span>Types and constants</span></a></li><li><a class="tocitem" href="#Functions-and-macros"><span>Functions and macros</span></a></li><li class="toplevel"><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../pullbacks/">Implementing pullbacks</a></li><li><a class="tocitem" href="../dev_docs/">For developers</a></li><li><a class="tocitem" href="../internal_api/">Internal API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EnzymeAD/Enzyme.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Types-and-constants"><a class="docs-heading-anchor" href="#Types-and-constants">Types and constants</a><a id="Types-and-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-constants" title="Permalink"></a></h2><ul><li><a href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a></li><li><a href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a></li><li><a href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a></li><li><a href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a></li><li><a href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a></li><li><a href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a></li><li><a href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a></li><li><a href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a></li><li><a href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a></li><li><a href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a></li><li><a href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a></li><li><a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a></li><li><a href="#EnzymeCore.EnzymeRules.Config"><code>EnzymeCore.EnzymeRules.Config</code></a></li></ul><h2 id="Functions-and-macros"><a class="docs-heading-anchor" href="#Functions-and-macros">Functions and macros</a><a id="Functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-macros" title="Permalink"></a></h2><ul><li><a href="#Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient-Tuple{ReverseMode, Any, Any}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient!-Tuple{ReverseMode, Any, Any, Any}"><code>Enzyme.gradient!</code></a></li><li><a href="#Enzyme.jacobian-Tuple{ForwardMode, Any, Any}"><code>Enzyme.jacobian</code></a></li><li><a href="#Enzyme.jacobian-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RABI}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}"><code>Enzyme.jacobian</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{A}, Tuple{FA}, Tuple{ForwardMode, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_deferred_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a></li><li><a href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a></li><li><a href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a></li><li><a href="#Enzyme.API.runtimeActivity-Tuple{}"><code>Enzyme.API.runtimeActivity</code></a></li><li><a href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>Enzyme.API.runtimeActivity!</code></a></li></ul><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Enzyme.gradient!-Tuple{ReverseMode, Any, Any, Any}" href="#Enzyme.gradient!-Tuple{ReverseMode, Any, Any, Any}"><code>Enzyme.gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient!(::ReverseMode, dx, f, x)</code></pre><p>Compute the gradient of an array-input function <code>f</code> using reverse mode, storing the derivative result in an existing array <code>dx</code>.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

dx = [0.0, 0.0]
gradient!(Reverse, dx, f, [2.0, 3.0])

# output

2-element Vector{Float64}:
 3.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L814-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.gradient-Tuple{ForwardMode, Any, Any}" href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ForwardMode, f, x; shadow=onehot(x))</code></pre><p>Compute the gradient of an array-input function <code>f</code> using forward mode. The optional keyword argument <code>shadow</code> is a vector of one-hot vectors of type <code>x</code> which are used to forward-propagate into the return. For performance reasons, this should be computed once, outside the call to <code>gradient</code>, rather than within this call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Forward, f, [2.0, 3.0])

# output

(3.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L841-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.gradient-Tuple{ReverseMode, Any, Any}" href="#Enzyme.gradient-Tuple{ReverseMode, Any, Any}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ReverseMode, f, x)</code></pre><p>Compute the gradient of an array-input function <code>f</code> using reverse mode. This will allocate and return new array with the gradient result.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Reverse, f, [2.0, 3.0])

# output

2-element Vector{Float64}:
 3.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L787-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}" href="#Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ForwardMode, f, x, ::Val{chunk}; shadow=onehot(x))</code></pre><p>Compute the gradient of an array-input function <code>f</code> using vector forward mode. Like <a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>gradient</code></a>, except it uses a chunk size of <code>chunk</code> to compute <code>chunk</code> derivatives in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Forward, f, [2.0, 3.0], Val(2))

# output

(3.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L882-L900">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.jacobian-Tuple{ForwardMode, Any, Any}" href="#Enzyme.jacobian-Tuple{ForwardMode, Any, Any}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(::ForwardMode, f, x; shadow=onehot(x))
jacobian(::ForwardMode, f, x, ::Val{chunk}; shadow=onehot(x))</code></pre><p>Compute the jacobian of an array-input function <code>f</code> using (potentially vector) forward mode. This is a simple rename of the <a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>gradient</code></a> function, and all relevant arguments apply here.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = [x[1]*x[2], x[2]]

grad = jacobian(Forward, f, [2.0, 3.0])

# output

2×2 Matrix{Float64}:
 3.0  2.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L917-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.jacobian-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RABI}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}" href="#Enzyme.jacobian-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RABI}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(::ReverseMode, f, x, ::Val{num_outs}, ::Val{chunk})</code></pre><p>Compute the jacobian of an array-input function <code>f</code> using (potentially vector) reverse mode. The <code>chunk</code> argument denotes the chunk size to use and <code>num_outs</code> denotes the number of outputs <code>f</code> will return in an array.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = [x[1]*x[2], x[2]]

grad = jacobian(Reverse, f, [2.0, 3.0], Val(2))

# output

2×2 Matrix{Float64}:
 3.0  2.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L966-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}" href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(::ForwardMode, f, Activity, args...)</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using forward mode.</p><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or similar argument. Non-annotated arguments will automatically be treated as <a href="#EnzymeCore.Const"><code>Const</code></a>. Unlike reverse mode in <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> arguments are not allowed here, since all derivative results of immutable objects will be returned and should instead use <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or variants like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>.</p><p><code>Activity</code> is the Activity of the return value, it may be:</p><ul><li><code>Const</code> if the return is not to be differentiated with respect to</li><li><code>Duplicated</code>, if the return is being differentiated with respect to and both the original value and the derivative return are desired</li><li><code>DuplicatedNoNeed</code>, if the return is being differentiated with respect to and only the derivative return is desired.</li><li><code>BatchDuplicated</code>, like <code>Duplicated</code>, but computing multiple derivatives at once. All batch sizes must be the same for all arguments.</li><li><code>BatchDuplicatedNoNeed</code>, like <code>DuplicatedNoNeed</code>, but computing multiple derivatives at one. All batch sizes must be the same for all arguments.</li></ul><p>Example returning both original return and derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
res, ∂f_∂x = autodiff(Forward, f, Duplicated, Duplicated(3.14, 1.0))

# output

(9.8596, 6.28)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
∂f_∂x = autodiff(Forward, f, DuplicatedNoNeed, Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L239-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, CMode&lt;:EnzymeCore.Mode}" href="#EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, args...)</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> but will try to guess the activity of the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}" href="#EnzymeCore.autodiff-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, ::Type{A}, args...)</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> but will try to extend f to an annotation, if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}" href="#EnzymeCore.autodiff-Union{Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(::ReverseMode, f, Activity, args...)</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using reverse mode.</p><p>Limitations:</p><ul><li><code>f</code> may only return a <code>Real</code> (of a built-in/primitive type) or <code>nothing</code>, not an array, struct, <code>BigFloat</code>, etc. To handle vector-valued return types, use a mutating <code>f!</code> that returns <code>nothing</code> and stores it&#39;s return value in one of the arguments, which must be wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</li></ul><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in an <a href="#EnzymeCore.Active"><code>Active</code></a> (for arguments whose derivative result must be returned rather than mutated in place, such as primitive types and structs thereof) or <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> (for mutable arguments like arrays, <code>Ref</code>s and structs thereof). Non-annotated arguments will automatically be treated as <a href="#EnzymeCore.Const"><code>Const</code></a>.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Active</code>.</p><p>Example:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(a, b, c, d) = a * √(b[1]^2 + b[2]^2) + c^2 * d^2
∂f_∂a, _, _, ∂f_∂d = autodiff(Reverse, f, Active, Active(a), Duplicated(b, ∂f_∂b), c, Active(d))[1]

# output

(3.966106403010388, nothing, nothing, 54450.0)</code></pre><p>here, <code>autodiff</code> returns a tuple <span>$(\partial f/\partial a, \partial f/\partial d)$</span>, while <span>$\partial f/\partial b$</span> will be <em>added to</em> <code>∂f_∂b</code> (but not returned). <code>c</code> will be treated as <code>Const(c)</code>.</p><p>One can also request the original returned value of the computation.</p><p>Example:</p><pre><code class="language-julia hljs">Enzyme.autodiff(ReverseWithPrimal, x-&gt;x*x, Active(3.0))

# output

((6.0,), 9.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L118-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{A}, Tuple{FA}, Tuple{ForwardMode, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{A}, Tuple{FA}, Tuple{ForwardMode, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ForwardMode, f, Activity, args...)</code></pre><p>Same as <code>autodiff(::ForwardMode, ...)</code> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L375-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Any}}} where {F, CMode&lt;:EnzymeCore.Mode}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(mode::Mode, f, ::Type{A}, args...)</code></pre><p>Like <a href="#EnzymeCore.autodiff_deferred-Union{Tuple{A}, Tuple{FA}, Tuple{ForwardMode, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff_deferred</code></a> but will try to extend f to an annotation, if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L436-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal}, FA, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ReverseMode, f, Activity, args...)</code></pre><p>Same as <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L333-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_deferred_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}" href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_deferred_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred_thunk(::ReverseModeSplit, ftype, Activity, argtypes...)</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

forward, reverse = autodiff_deferred_thunk(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A 

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L622-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, RABI&lt;:EnzymeCore.ABI}" href="#EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ForwardMode, ftype, Activity, argtypes...)</code></pre><p>Provide the thunk forward mode function for annotated function type ftype when called with args of type <code>argtypes</code>.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and<code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return the primal (if requested) and the shadow (or nothing if not a <code>Duplicated</code> variant).</p><p>Example returning both original return and derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(Forward, Const{typeof(f)}, Duplicated, Duplicated{Float64})
res, ∂f_∂x = forward(Const(f), Duplicated(3.14, 1.0))

# output

(9.8596, 6.28)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(Forward, Const{typeof(f)}, DuplicatedNoNeed, Duplicated{Float64})
∂f_∂x = forward(Const(f), Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L531-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}" href="#EnzymeCore.autodiff_thunk-Union{Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI}, Type{FA}, Type{A}, Vararg{Any}}} where {FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ReverseModeSplit, ftype, Activity, argtypes...)</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

forward, reverse = autodiff_thunk(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A 

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/Enzyme.jl#L462-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.ABI" href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ABI</code></pre><p>Abstract type for what ABI  will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.Active" href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Active(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> as active, Enzyme will auto-differentiate in respect <code>Active</code> arguments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.Annotation" href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Annotation{T}</code></pre><p>Abstract type for <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> function argument wrappers like <a href="#EnzymeCore.Const"><code>Const</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> and <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.BatchDuplicated" href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchDuplicated(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.BatchDuplicatedNoNeed" href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchDuplicatedNoNeed(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.Const" href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Const(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> as constant, Enzyme will not auto-differentiate in respect <code>Const</code> arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.Duplicated" href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Duplicated(x, ∂f_∂x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{RABI}, Tuple{ForwardMode{RABI}, FA, Type{A}, Vararg{Any}}} where {RABI&lt;:EnzymeCore.ABI, FA&lt;:EnzymeCore.Annotation, A&lt;:EnzymeCore.Annotation}"><code>autodiff</code></a> as duplicated, Enzyme will auto-differentiate in respect to such arguments, with <code>dx</code> acting as an accumulator for gradients (so <span>$\partial f / \partial x$</span> will be <em>added to</em>) <code>∂f_∂x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.DuplicatedNoNeed" href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DuplicatedNoNeed(x, ∂f_∂x)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except also specifies that Enzyme may avoid computing the original result and only compute the derivative values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.FFIABI" href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFIABI &lt;: ABI</code></pre><p>Foreign function call ABI. JIT the differentiated function, then inttoptr call the address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.ForwardMode" href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Forward &lt;: Mode</code></pre><p>Forward mode differentiation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.Mode" href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Mode</code></pre><p>Abstract type for what differentiation mode will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.ReverseMode" href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReverseMode{ReturnPrimal,ABI} &lt;: Mode{ABI}</code></pre><p>Reverse mode differentiation.</p><ul><li><code>ReturnPrimal</code>: Should Enzyme return the primal return value from the augmented-forward.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.ReverseModeSplit" href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReverseModeSplit{ReturnPrimal,ReturnShadow,Width,ModifiedBetween,ABI} &lt;: Mode{ABI}</code></pre><p>Reverse mode differentiation.</p><ul><li><code>ReturnPrimal</code>: Should Enzyme return the primal return value from the augmented-forward.</li><li><code>ReturnShadow</code>: Should Enzyme return the shadow return value from the augmented-forward.</li><li><code>Width</code>: Batch Size (0 if to be automatically derived)</li><li><code>ModifiedBetween</code>: Tuple of each argument&#39;s modified between state (true if to be automatically derived).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/EnzymeCore.jl#L147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.AugmentedReturn" href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AugmentedReturn(primal, shadow, tape)</code></pre><p>Augment the primal return value of a function with its shadow, as well as any additional information needed to correctly  compute the reverse pass, stored in <code>tape</code>.</p><p>Unless specified by the config that a variable is not overwritten, rules must assume any arrays/data structures/etc are  overwritten between the forward and the reverse pass. Any floats or variables passed by value are always preserved as is  (as are the arrays themselves, just not necessarily the values in the array).</p><p>See also <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.Config" href="#EnzymeCore.EnzymeRules.Config"><code>EnzymeCore.EnzymeRules.Config</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Config{NeedsPrimal, NeedsShadow, Width, Overwritten}
ConfigWidth{Width} = Config{&lt;:Any,&lt;:Any, Width}</code></pre><p>Configuration type to dispatch on in custom reverse rules (see <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a> and <a href="#EnzymeCore.EnzymeRules.reverse"><code>reverse</code></a>).</p><ul><li><code>NeedsPrimal</code> and <code>NeedsShadow</code>: boolean values specifying whether the primal and shadow (resp.) should be returned. </li><li><code>Width</code>: an integer that specifies the number of adjoints/shadows simultaneously being propagated.</li><li><code>Overwritten</code>: a tuple of booleans of whether each argument (including the function itself) is modified between the   forward and reverse pass (true if potentially modified between).</li></ul><p>Getters for the four type parameters are provided by <code>needs_primal</code>, <code>needs_shadow</code>, <code>width</code>, and <code>overwritten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L21-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.augmented_primal" href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">augmented_primal(::Config, func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Must return an <a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>AugmentedReturn</code></a> type.</p><ul><li>The primal must be the same type of the original return if <code>needs_primal(config)</code>, otherwise nothing.</li><li>The shadow must be nothing if needs_shadow(config) is false. If width is 1, the shadow should be the same type of the original return. If the width is greater than 1, the shadow should be NTuple{original return, width}.</li><li>The tape can be any type (including Nothing) and is preserved for the reverse call.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.forward" href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forward(func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Calculate the forward derivative. The first argument <code>func</code> is the callable for which the rule applies to. Either wrapped in a <a href="#EnzymeCore.Const"><code>Const</code></a>), or a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> if it is a closure. The second argument is the return type annotation, and all other arguments are the annotated function arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.inactive" href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inactive(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.inactive_noinl" href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inactive_noinl(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself, but do not prevent inlining of the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EnzymeCore.EnzymeRules.reverse" href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(::Config, func::Annotation{typeof(f)}, dret::Active, tape, args::Annotation...)
reverse(::Config, func::Annotation{typeof(f)}, ::Type{&lt;:Annotation), tape, args::Annotation...)</code></pre><p>Takes gradient of derivative, activity annotation, and tape. If there is an active return dret is passed as Active{T} with the derivative of the active return val. Otherwise dret is passed as Type{Duplicated{T}}, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/lib/EnzymeCore/src/rules.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.API.runtimeActivity!-Tuple{Bool}" href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>Enzyme.API.runtimeActivity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runtimeActivity!(val::Bool)</code></pre><p>Enzyme runs an activity analysis which deduces which values, instructions, etc are necessary to be differentiated and therefore involved in the differentiation procedure. This runs at compile time. However, there may be implementation flaws in this analysis that means that Enzyme cannot deduce that an inactive (const) value is actually const. Alternatively, there may be some data which is conditionally active, depending on which runtime branch is taken. In these cases Enzyme conservatively presumes the value is active.</p><p>However, in certain cases, an insufficiently aggressive activity analysis may result in derivative errors – for example by mistakenly using the primal (const) argument and mistaking it for the duplicated shadow. As a result this may result in incorrect results, or accidental updates to the primal.</p><p>This flag enables runntime activity which tells all load/stores to check at runtime whether the value they are updating is indeed active (in addition to the compile-time activity analysis). This will remedy these such errors, but at a performance penalty of performing such checks.</p><p>It is on the Enzyme roadmap to add a PotentiallyDuplicated style activity, in addition to the current Const and Duplicated styles that will disable the need for this, which does  not require the check when a value is guaranteed active, but still supports runtime-based activity information.</p><p>This function takes an argument to set the runtime activity value, true means it is on, and false means off. By default it is off.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/api.jl#L369-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Enzyme.API.runtimeActivity-Tuple{}" href="#Enzyme.API.runtimeActivity-Tuple{}"><code>Enzyme.API.runtimeActivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runtimeActivity()</code></pre><p>Gets the current value of the runtime activity. See <a href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>runtimeActivity!</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/f734711c60ab36eee27c91bfea5edafcae822d8f/src/api.jl#L403-L408">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/custom_rule/">« Custom rules</a><a class="docs-footer-nextpage" href="../pullbacks/">Implementing pullbacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 July 2023 18:16">Thursday 20 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
