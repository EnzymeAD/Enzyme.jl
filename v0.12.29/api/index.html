<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · Enzyme.jl</title><meta name="title" content="API reference · Enzyme.jl"/><meta property="og:title" content="API reference · Enzyme.jl"/><meta property="twitter:title" content="API reference · Enzyme.jl"/><meta name="description" content="Documentation for Enzyme.jl."/><meta property="og:description" content="Documentation for Enzyme.jl."/><meta property="twitter:description" content="Documentation for Enzyme.jl."/><meta property="og:url" content="https://enzyme.mit.edu/julia/api/"/><meta property="twitter:url" content="https://enzyme.mit.edu/julia/api/"/><link rel="canonical" href="https://enzyme.mit.edu/julia/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="https://plausible.io/js/plausible.js" data-domain="enzyme.mit.edu" defer></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Enzyme.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Enzyme.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/autodiff/">Basics</a></li><li><a class="tocitem" href="../generated/box/">Box model</a></li><li><a class="tocitem" href="../generated/custom_rule/">Custom rules</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Types-and-constants"><span>Types and constants</span></a></li><li><a class="tocitem" href="#Functions-and-macros"><span>Functions and macros</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../dev_docs/">For developers</a></li><li><a class="tocitem" href="../internal_api/">Internal API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EnzymeAD/Enzyme.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="Types-and-constants"><a class="docs-heading-anchor" href="#Types-and-constants">Types and constants</a><a id="Types-and-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-constants" title="Permalink"></a></h2><ul><li><a href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a></li><li><a href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a></li><li><a href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a></li><li><a href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a></li><li><a href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.BatchMixedDuplicated"><code>EnzymeCore.BatchMixedDuplicated</code></a></li><li><a href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a></li><li><a href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a></li><li><a href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a></li><li><a href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a></li><li><a href="#EnzymeCore.InlineABI"><code>EnzymeCore.InlineABI</code></a></li><li><a href="#EnzymeCore.MixedDuplicated"><code>EnzymeCore.MixedDuplicated</code></a></li><li><a href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a></li><li><a href="#EnzymeCore.NonGenABI"><code>EnzymeCore.NonGenABI</code></a></li><li><a href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a></li><li><a href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a></li><li><a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a></li><li><a href="#EnzymeCore.EnzymeRules.Config"><code>EnzymeCore.EnzymeRules.Config</code></a></li><li><a href="#EnzymeTestUtils.ExprAndMsg"><code>EnzymeTestUtils.ExprAndMsg</code></a></li></ul><h2 id="Functions-and-macros"><a class="docs-heading-anchor" href="#Functions-and-macros">Functions and macros</a><a id="Functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-macros" title="Permalink"></a></h2><ul><li><a href="#Enzyme.@import_frule-Tuple"><code>Enzyme.@import_frule</code></a></li><li><a href="#Enzyme.@import_rrule-Tuple"><code>Enzyme.@import_rrule</code></a></li><li><a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}"><code>Enzyme.gradient!</code></a></li><li><a href="#Enzyme.gradient_deferred-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}"><code>Enzyme.gradient_deferred</code></a></li><li><a href="#Enzyme.gradient_deferred!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}"><code>Enzyme.gradient_deferred!</code></a></li><li><a href="#Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}"><code>Enzyme.hvp</code></a></li><li><a href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>Enzyme.hvp!</code></a></li><li><a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>Enzyme.hvp_and_gradient!</code></a></li><li><a href="#Enzyme.jacobian-Union{Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{false, RABI, ErrIfFuncWritten}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten}"><code>Enzyme.jacobian</code></a></li><li><a href="#Enzyme.jacobian-Tuple{ForwardMode, Any, Any}"><code>Enzyme.jacobian</code></a></li><li><a href="#Enzyme.typetree"><code>Enzyme.typetree</code></a></li><li><a href="#Enzyme.unsafe_to_pointer-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Enzyme.unsafe_to_pointer</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, ABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{ABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, Nargs, ABI, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.compiler_job_from_backend"><code>EnzymeCore.compiler_job_from_backend</code></a></li><li><a href="#EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}"><code>EnzymeCore.make_zero</code></a></li><li><a href="#EnzymeCore.make_zero"><code>EnzymeCore.make_zero</code></a></li><li><a href="#EnzymeCore.make_zero!"><code>EnzymeCore.make_zero!</code></a></li><li><a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a></li><li><a href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}"><code>EnzymeCore.EnzymeRules.inactive_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.noalias"><code>EnzymeCore.EnzymeRules.noalias</code></a></li><li><a href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a></li><li><a href="#EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.@test_msg</code></a></li><li><a href="#EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}"><code>EnzymeTestUtils.are_activities_compatible</code></a></li><li><a href="#EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_forward</code></a></li><li><a href="#EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_reverse</code></a></li><li><a href="#Enzyme.API.fast_math!-Tuple{Any}"><code>Enzyme.API.fast_math!</code></a></li><li><a href="#Enzyme.API.inlineall!-Tuple{Any}"><code>Enzyme.API.inlineall!</code></a></li><li><a href="#Enzyme.API.instname!-Tuple{Any}"><code>Enzyme.API.instname!</code></a></li><li><a href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>Enzyme.API.looseTypeAnalysis!</code></a></li><li><a href="#Enzyme.API.maxtypedepth!-Tuple{Any}"><code>Enzyme.API.maxtypedepth!</code></a></li><li><a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>Enzyme.API.maxtypeoffset!</code></a></li><li><a href="#Enzyme.API.memmove_warning!-Tuple{Any}"><code>Enzyme.API.memmove_warning!</code></a></li><li><a href="#Enzyme.API.printactivity!-Tuple{Any}"><code>Enzyme.API.printactivity!</code></a></li><li><a href="#Enzyme.API.printall!-Tuple{Any}"><code>Enzyme.API.printall!</code></a></li><li><a href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>Enzyme.API.printdiffuse!</code></a></li><li><a href="#Enzyme.API.printperf!-Tuple{Any}"><code>Enzyme.API.printperf!</code></a></li><li><a href="#Enzyme.API.printtype!-Tuple{Any}"><code>Enzyme.API.printtype!</code></a></li><li><a href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>Enzyme.API.printunnecessary!</code></a></li><li><a href="#Enzyme.API.runtimeActivity-Tuple{}"><code>Enzyme.API.runtimeActivity</code></a></li><li><a href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>Enzyme.API.runtimeActivity!</code></a></li><li><a href="#Enzyme.API.strictAliasing!-Tuple{Any}"><code>Enzyme.API.strictAliasing!</code></a></li><li><a href="#Enzyme.API.strong_zero!-Tuple{Any}"><code>Enzyme.API.strong_zero!</code></a></li><li><a href="#Enzyme.API.typeWarning!-Tuple{Any}"><code>Enzyme.API.typeWarning!</code></a></li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.@import_frule-Tuple" href="#Enzyme.@import_frule-Tuple"><code>Enzyme.@import_frule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">import_frule(::fn, tys...)</code></pre><p>Automatically import a <code>ChainRulesCore.frule</code><code>as a custom forward mode</code>EnzymeRule<code>. When called in batch mode, this will end up calling the primal multiple times, which may result in incorrect behavior if the function mutates, and slow code, always. Importing the rule from</code>ChainRules` is also likely to be slower than writing your own rule, and may also be slower than not having a rule at all.</p><p>Use with caution.</p><pre><code class="language-julia hljs">Enzyme.@import_frule(typeof(Base.sort), Any);

x=[1.0, 2.0, 0.0]; dx=[0.1, 0.2, 0.3]; ddx = [0.01, 0.02, 0.03];

Enzyme.autodiff(Forward, sort, Duplicated, BatchDuplicated(x, (dx,ddx)))
Enzyme.autodiff(Forward, sort, DuplicatedNoNeed, BatchDuplicated(x, (dx,ddx)))
Enzyme.autodiff(Forward, sort, DuplicatedNoNeed, BatchDuplicated(x, (dx,)))
Enzyme.autodiff(Forward, sort, Duplicated, BatchDuplicated(x, (dx,)))

# output

(var&quot;1&quot; = [0.0, 1.0, 2.0], var&quot;2&quot; = (var&quot;1&quot; = [0.3, 0.1, 0.2], var&quot;2&quot; = [0.03, 0.01, 0.02]))
(var&quot;1&quot; = (var&quot;1&quot; = [0.3, 0.1, 0.2], var&quot;2&quot; = [0.03, 0.01, 0.02]),)
(var&quot;1&quot; = [0.3, 0.1, 0.2],)
(var&quot;1&quot; = [0.0, 1.0, 2.0], var&quot;2&quot; = [0.3, 0.1, 0.2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1613-L1641">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.@import_rrule-Tuple" href="#Enzyme.@import_rrule-Tuple"><code>Enzyme.@import_rrule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">import_rrule(::fn, tys...)</code></pre><p>Automatically import a ChainRules.rrule as a custom reverse mode EnzymeRule. When called in batch mode, this will end up calling the primal multiple times which results in slower code. This macro assumes that the underlying function to be imported is read-only, and returns a Duplicated or Const object. This macro also assumes that the inputs permit a .+= operation and that the output has a valid Enzyme.make_zero function defined. It also assumes that overwritten(x) accurately describes if there is any non-preserved data from forward to reverse, not just the outermost data structure being overwritten as provided by the specification.</p><p>Finally, this macro falls back to almost always caching all of the inputs, even if it may not be needed for the derivative computation.</p><p>As a result, this auto importer is also likely to be slower than writing your own rule, and may also be slower than not having a rule at all.</p><p>Use with caution.</p><pre><code class="language-julia hljs">Enzyme.@import_rrule(typeof(Base.sort), Any);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1648-L1669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}" href="#Enzyme.gradient!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}"><code>Enzyme.gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient!(::ReverseMode, dx, f, x)</code></pre><p>Compute the gradient of an array-input function <code>f</code> using reverse mode, storing the derivative result in an existing array <code>dx</code>. Both <code>x</code> and <code>dx</code> must be <code>Array</code>s of the same type.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

dx = [0.0, 0.0]
gradient!(Reverse, dx, f, [2.0, 3.0])

# output

2-element Vector{Float64}:
 3.0
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1071-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient-Tuple{ForwardMode, Any, Any}" href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ForwardMode, f, x; shadow=onehot(x))</code></pre><p>Compute the gradient of an array-input function <code>f</code> using forward mode. The optional keyword argument <code>shadow</code> is a vector of one-hot vectors of type <code>x</code> which are used to forward-propagate into the return. For performance reasons, this should be computed once, outside the call to <code>gradient</code>, rather than within this call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Forward, f, [2.0, 3.0])

# output

(3.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1111-L1131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}" href="#Enzyme.gradient-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ReverseMode, f, x)</code></pre><p>Compute the gradient of a real-valued function <code>f</code> using reverse mode. This will allocate and return new array <code>make_zero(x)</code> with the gradient result.</p><p>Besides arrays, for struct <code>x</code> it returns another instance of the same type, whose fields contain the components of the gradient. In the result, <code>grad.a</code> contains <code>∂f/∂x.a</code> for any differential <code>x.a</code>, while <code>grad.c == x.c</code> for other types.</p><p>Examples:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Reverse, f, [2.0, 3.0])

# output

2-element Vector{Float64}:
 3.0
 2.0</code></pre><pre><code class="language-julia hljs">grad = gradient(Reverse, only ∘ f, (a = 2.0, b = [3.0], c = &quot;str&quot;))

# output

(a = 3.0, b = [2.0], c = &quot;str&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1009-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}" href="#Enzyme.gradient-Union{Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ForwardMode, F, X, Val{chunk}}} where {F, X, chunk}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient(::ForwardMode, f, x::Union{Array,NTuple}, ::Val{chunk}; shadow=onehot(x))</code></pre><p>Compute the gradient of an array-input function <code>f</code> using vector forward mode. Like <a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>gradient</code></a>, except it uses a chunk size of <code>chunk</code> to compute <code>chunk</code> derivatives in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Forward, f, [2.0, 3.0], Val(2))

# output

(3.0, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1161-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient_deferred!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}" href="#Enzyme.gradient_deferred!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}"><code>Enzyme.gradient_deferred!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient_deferred!(::ReverseMode, f, x)</code></pre><p>Like <a href="#Enzyme.gradient!-Union{Tuple{F}, Tuple{X}, Tuple{ReverseMode, X, F, X}} where {X&lt;:Array, F}"><code>gradient!</code></a>, except it using deferred mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1100-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.gradient_deferred-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}" href="#Enzyme.gradient_deferred-Union{Tuple{X}, Tuple{F}, Tuple{ReverseMode, F, X}} where {F, X}"><code>Enzyme.gradient_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient_deferred(::ReverseMode, f, x)</code></pre><p>Like <a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>gradient</code></a>, except it using deferred mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1054-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}" href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>Enzyme.hvp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hvp!(res::X, f::F, x::X, v::X) where {F, X}</code></pre><p>Compute an in-place Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code>. The result will be stored into <code>res</code>. The function still allocates and zero&#39;s a buffer to store the intermediate gradient, which is not returned to the user.</p><p>In other words, compute res .= hessian(f)(x) * v</p><p>See <a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>hvp_and_gradient!</code></a> for a function to compute both the hvp and the gradient in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

res = Vector{Float64}(undef, 2)
hvp!(res, f, [2.0, 3.0], [5.0, 2.7])

res
# output
2-element Vector{Float64}:
 19.6926882637302
 16.201003759768003</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1543-L1568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}" href="#Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}"><code>Enzyme.hvp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hvp(f::F, x::X, v::X) where {F, X}</code></pre><p>Compute the Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code>.</p><p>In other words, compute hessian(f)(x) * v</p><p>See <a href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>hvp!</code></a> for a version which stores the result in an existing buffer and also <a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>hvp_and_gradient!</code></a> for a function to compute both the hvp and the gradient in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

hvp(f, [2.0, 3.0], [5.0, 2.7])

# output
2-element Vector{Float64}:
 19.6926882637302
 16.201003759768003</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1514-L1535">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}" href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>Enzyme.hvp_and_gradient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hvp_and_gradient!(res::X, grad::X, f::F, x::X, v::X) where {F, X}</code></pre><p>Compute an in-place Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code> as well as the gradient, storing the gradient into <code>grad</code>. Both the hessian vector product and the gradient can be computed together more efficiently than computing them separately.</p><p>The result will be stored into <code>res</code>. The gradient will be stored into <code>grad</code>.</p><p>In other words, compute res .= hessian(f)(x) * v  and grad .= gradient(Reverse, f)(x)</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

res = Vector{Float64}(undef, 2)
grad = Vector{Float64}(undef, 2)
hvp_and_gradient!(res, grad, f, [2.0, 3.0], [5.0, 2.7])

res
grad
# output
2-element Vector{Float64}:
 2.880510859951098
 1.920340573300732</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1577-L1604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.jacobian-Tuple{ForwardMode, Any, Any}" href="#Enzyme.jacobian-Tuple{ForwardMode, Any, Any}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(::ForwardMode, f, x; shadow=onehot(x))
jacobian(::ForwardMode, f, x, ::Val{chunk}; shadow=onehot(x))</code></pre><p>Compute the jacobian of an array or scalar-input function <code>f</code> using (potentially vector) forward mode. All relevant arguments of the forward-mode <a href="#Enzyme.gradient-Tuple{ForwardMode, Any, Any}"><code>gradient</code></a> function apply here.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = jacobian(Forward, f, [2.0, 3.0, 4.0])

# output

2×3 Matrix{Float64}:
 3.0  2.0  0.0
 0.0  1.0  1.0</code></pre><p>For functions which return an AbstractArray, this function will return an array whose shape is <code>(size(output)..., size(input)...)</code></p><p>For functions who return other types, this function will retun an array or tuple of shape <code>size(input)</code> of values of the output type. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1206-L1233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.jacobian-Union{Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{false, RABI, ErrIfFuncWritten}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten}" href="#Enzyme.jacobian-Union{Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{n_out_val}, Tuple{chunk}, Tuple{X}, Tuple{F}, Tuple{ReverseMode{false, RABI, ErrIfFuncWritten}, F, X, Val{n_out_val}, Val{chunk}}} where {F, X, chunk, n_out_val, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(::ReverseMode, f, x, ::Val{num_outs}, ::Val{chunk}=Val(1))
jacobian(::ReverseMode, f, x)</code></pre><p>Compute the jacobian of an array-output function <code>f</code> using (potentially vector) reverse mode. The <code>chunk</code> argument denotes the chunk size to use and <code>num_outs</code> denotes the number of outputs <code>f</code> will return in an array.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = jacobian(Reverse, f, [2.0, 3.0, 4.0], Val(2))

# output

2×3 transpose(::Matrix{Float64}) with eltype Float64:
 3.0  2.0  0.0
 0.0  1.0  1.0</code></pre><p>For functions which return an AbstractArray, this function will return an array whose shape is <code>(size(output)..., size(input)...)</code></p><p>For functions who return other types, this function will retun an array or tuple of shape <code>size(output)</code> of values of the input type.  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L1335-L1363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.typetree" href="#Enzyme.typetree"><code>Enzyme.typetree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function typetree(T, ctx, dl, seen=TypeTreeTable())</code></pre><p>Construct a Enzyme typetree from a Julia type.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When using a memoized lookup by providing <code>seen</code> across multiple calls to typtree the user must call <code>copy</code> on the returned value before mutating it.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/typetree.jl#L71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.unsafe_to_pointer-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Enzyme.unsafe_to_pointer-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Enzyme.unsafe_to_pointer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_to_pointer</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Assumes that <code>val</code> is globally rooted and pointer to it can be leaked. Prefer <code>pointer_from_objref</code>. Only use inside Enzyme.jl should be for Types.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}" href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(::ForwardMode, f, Activity, args::Vararg{&lt;:Annotation, Nargs})</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using forward mode.</p><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or similar argument. Unlike reverse mode in <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> arguments are not allowed here, since all derivative results of immutable objects will be returned and should instead use <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or variants like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>.</p><p><code>Activity</code> is the Activity of the return value, it may be:</p><ul><li><code>Const</code> if the return is not to be differentiated with respect to</li><li><code>Duplicated</code>, if the return is being differentiated with respect to and both the original value and the derivative return are desired</li><li><code>DuplicatedNoNeed</code>, if the return is being differentiated with respect to and only the derivative return is desired.</li><li><code>BatchDuplicated</code>, like <code>Duplicated</code>, but computing multiple derivatives at once. All batch sizes must be the same for all arguments.</li><li><code>BatchDuplicatedNoNeed</code>, like <code>DuplicatedNoNeed</code>, but computing multiple derivatives at one. All batch sizes must be the same for all arguments.</li></ul><p>Example returning both original return and derivative:</p><pre><code class="language-julia hljs">f(x) = x*x
res, ∂f_∂x = autodiff(Forward, f, Duplicated, Duplicated(3.14, 1.0))

# output

(9.8596, 6.28)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">f(x) = x*x
∂f_∂x = autodiff(Forward, f, DuplicatedNoNeed, Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L351-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}" href="#EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(::ReverseMode, f, Activity, args::Vararg{&lt;:Annotation, Nargs})</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using reverse mode.</p><p>Limitations:</p><ul><li><code>f</code> may only return a <code>Real</code> (of a built-in/primitive type) or <code>nothing</code>, not an array, struct, <code>BigFloat</code>, etc. To handle vector-valued return types, use a mutating <code>f!</code> that returns <code>nothing</code> and stores it&#39;s return value in one of the arguments, which must be wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</li></ul><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in an <a href="#EnzymeCore.Active"><code>Active</code></a> (for arguments whose derivative result must be returned rather than mutated in place, such as primitive types and structs thereof) or <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> (for mutable arguments like arrays, <code>Ref</code>s and structs thereof).</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Active</code>.</p><p>Example:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(a, b, c, d) = a * √(b[1]^2 + b[2]^2) + c^2 * d^2
∂f_∂a, _, _, ∂f_∂d = autodiff(Reverse, f, Active, Active(a), Duplicated(b, ∂f_∂b), Const(c), Active(d))[1]

# output

(3.966106403010388, nothing, nothing, 54450.0)</code></pre><p>here, <code>autodiff</code> returns a tuple <span>$(\partial f/\partial a, \partial f/\partial d)$</span>, while <span>$\partial f/\partial b$</span> will be <em>added to</em> <code>∂f_∂b</code> (but not returned). <code>c</code> will be treated as <code>Const(c)</code>.</p><p>One can also request the original returned value of the computation.</p><p>Example:</p><pre><code class="language-julia hljs">Enzyme.autodiff(ReverseWithPrimal, x-&gt;x*x, Active(3.0))

# output

((6.0,), 9.0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L172-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:EnzymeCore.Mode, Nargs}" href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, args...)</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but will try to guess the activity of the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L335-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}" href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, ::Type{A}, args::Vararg{Annotation, Nargs})</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but will try to extend f to an annotation, if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{ABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, Nargs, ABI, ErrIfFuncWritten}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{ABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, Nargs, ABI, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ForwardMode, f, Activity, args::Vararg{&lt;:Annotation, Nargs})</code></pre><p>Same as <code>autodiff(::ForwardMode, f, Activity, args)</code> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L481-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, ABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, ABI, Holomorphic, ErrIfFuncWritten}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, ABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ReverseMode, f, Activity, args::Vararg{&lt;:Annotation, Nargs})</code></pre><p>Same as <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L440-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_deferred-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}" href="#EnzymeCore.autodiff_deferred-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:EnzymeCore.Mode, Nargs}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred(mode::Mode, f, ::Type{A}, args)</code></pre><p>Like <a href="#EnzymeCore.autodiff_deferred-Union{Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{ABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, Nargs, ABI, ErrIfFuncWritten}"><code>autodiff_deferred</code></a> but will try to extend f to an annotation, if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L539-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}" href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_deferred_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_deferred_thunk(::ReverseModeSplit, ftype, Activity, argtypes::Vararg{Type{&lt;:Annotation}, Nargs})</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

TapeType = tape_type(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})
forward, reverse = autodiff_deferred_thunk(ReverseSplitWithPrimal, TapeType, Const{typeof(f)}, Active{Float64}, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A 

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L812-L855">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}" href="#EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ForwardMode, ftype, Activity, argtypes::Vararg{Type{&lt;:Annotation}, Nargs})</code></pre><p>Provide the thunk forward mode function for annotated function type ftype when called with args of type <code>argtypes</code>.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and<code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return the primal (if requested) and the shadow (or nothing if not a <code>Duplicated</code> variant).</p><p>Example returning both original return and derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(Forward, Const{typeof(f)}, Duplicated, Duplicated{Float64})
res, ∂f_∂x = forward(Const(f), Duplicated(3.14, 1.0))

# output

(9.8596, 6.28)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(Forward, Const{typeof(f)}, DuplicatedNoNeed, Duplicated{Float64})
∂f_∂x = forward(Const(f), Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L646-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}" href="#EnzymeCore.autodiff_thunk-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{EnzymeCore.ReverseModeSplit{ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI, ErrIfFuncWritten}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ReverseModeSplit, ftype, Activity, argtypes::Vararg{Type{&lt;:Annotation, Nargs})</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

forward, reverse = autodiff_thunk(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A 

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/Enzyme.jl#L572-L614">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.ABI" href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ABI</code></pre><p>Abstract type for what ABI  will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.Active" href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Active(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as active, Enzyme will auto-differentiate in respect <code>Active</code> arguments.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.Annotation" href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Annotation{T}</code></pre><p>Abstract type for <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> function argument wrappers like <a href="#EnzymeCore.Const"><code>Const</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> and <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.BatchDuplicated" href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchDuplicated(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.BatchDuplicatedNoNeed" href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchDuplicatedNoNeed(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.BatchMixedDuplicated" href="#EnzymeCore.BatchMixedDuplicated"><code>EnzymeCore.BatchMixedDuplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchMixedDuplicated(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.MixedDuplicated"><code>MixedDuplicated</code></a>, except contains several shadows to compute derivatives for all at once. Only used within custom rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.Const" href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Const(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as constant, Enzyme will not auto-differentiate in respect <code>Const</code> arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.Duplicated" href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Duplicated(x, ∂f_∂x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ForwardMode{RABI, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as duplicated, Enzyme will auto-differentiate in respect to such arguments, with <code>dx</code> acting as an accumulator for gradients (so <span>$\partial f / \partial x$</span> will be <em>added to</em>) <code>∂f_∂x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.DuplicatedNoNeed" href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DuplicatedNoNeed(x, ∂f_∂x)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except also specifies that Enzyme may avoid computing the original result and only compute the derivative values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.FFIABI" href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FFIABI &lt;: ABI</code></pre><p>Foreign function call ABI. JIT the differentiated function, then inttoptr call the address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.ForwardMode" href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Forward &lt;: Mode</code></pre><p>Forward mode differentiation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.InlineABI" href="#EnzymeCore.InlineABI"><code>EnzymeCore.InlineABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InlineABI &lt;: ABI</code></pre><p>Inlining function call ABI. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.MixedDuplicated" href="#EnzymeCore.MixedDuplicated"><code>EnzymeCore.MixedDuplicated</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MixedDuplicated(x, ∂f_∂x)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except x may contain both active [immutable] and duplicated [mutable] data which is differentiable. Only used within custom rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.Mode" href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Mode</code></pre><p>Abstract type for what differentiation mode will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.NonGenABI" href="#EnzymeCore.NonGenABI"><code>EnzymeCore.NonGenABI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NonGenABI &lt;: ABI</code></pre><p>Non-generated function ABI. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.ReverseMode" href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReverseMode{ReturnPrimal,ABI,Holomorphic} &lt;: Mode{ABI}</code></pre><p>Reverse mode differentiation.</p><ul><li><code>ReturnPrimal</code>: Should Enzyme return the primal return value from the augmented-forward.</li><li><code>ABI</code>: What runtime ABI to use</li><li><code>Holomorphic</code>: Whether the complex result function is holomorphic and we should compute d/dz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L214-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.ReverseModeSplit" href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReverseModeSplit{ReturnPrimal,ReturnShadow,Width,ModifiedBetween,ABI} &lt;: Mode{ABI}</code></pre><p>Reverse mode differentiation.</p><ul><li><code>ReturnPrimal</code>: Should Enzyme return the primal return value from the augmented-forward.</li><li><code>ReturnShadow</code>: Should Enzyme return the shadow return value from the augmented-forward.</li><li><code>Width</code>: Batch Size (0 if to be automatically derived)</li><li><code>ModifiedBetween</code>: Tuple of each argument&#39;s modified between state (true if to be automatically derived).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L233-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.compiler_job_from_backend" href="#EnzymeCore.compiler_job_from_backend"><code>EnzymeCore.compiler_job_from_backend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compiler_job_from_backend(::KernelAbstractions.Backend, F::Type, TT:Type)::GPUCompiler.CompilerJob</code></pre><p>Returns a GPUCompiler CompilerJob from a backend as specified by the first argument to the function.</p><p>For example, in CUDA one would do:</p><pre><code class="language-julia hljs">function EnzymeCore.compiler_job_from_backend(::CUDABackend, @nospecialize(F::Type), @nospecialize(TT::Type))
    mi = GPUCompiler.methodinstance(F, TT)
    return GPUCompiler.CompilerJob(mi, CUDA.compiler_config(CUDA.device()))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L293-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.make_zero" href="#EnzymeCore.make_zero"><code>EnzymeCore.make_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_zero(::Type{T}, seen::IdDict, prev::T, ::Val{copy_if_inactive}=Val(false))::T

Recursively make a zero&#39;d copy of the value `prev` of type `T`. The argument `copy_if_inactive` specifies
what to do if the type `T` is guaranteed to be inactive, use the primal (the default) or still copy the value.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L267-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.make_zero!" href="#EnzymeCore.make_zero!"><code>EnzymeCore.make_zero!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_zero!(val::T, seen::IdSet{Any}=IdSet())::Nothing

Recursively set a variables differentiable fields to zero. Only applicable for mutable types `T`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}" href="#EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}"><code>EnzymeCore.make_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_zero(prev::T)

Helper function to recursively make zero.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/EnzymeCore.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.AugmentedReturn" href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AugmentedReturn(primal, shadow, tape)</code></pre><p>Augment the primal return value of a function with its shadow, as well as any additional information needed to correctly  compute the reverse pass, stored in <code>tape</code>.</p><p>Unless specified by the config that a variable is not overwritten, rules must assume any arrays/data structures/etc are  overwritten between the forward and the reverse pass. Any floats or variables passed by value are always preserved as is  (as are the arrays themselves, just not necessarily the values in the array).</p><p>See also <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.Config" href="#EnzymeCore.EnzymeRules.Config"><code>EnzymeCore.EnzymeRules.Config</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Config{NeedsPrimal, NeedsShadow, Width, Overwritten}
ConfigWidth{Width} = Config{&lt;:Any,&lt;:Any, Width}</code></pre><p>Configuration type to dispatch on in custom reverse rules (see <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a> and <a href="#EnzymeCore.EnzymeRules.reverse"><code>reverse</code></a>).</p><ul><li><code>NeedsPrimal</code> and <code>NeedsShadow</code>: boolean values specifying whether the primal and shadow (resp.) should be returned. </li><li><code>Width</code>: an integer that specifies the number of adjoints/shadows simultaneously being propagated.</li><li><code>Overwritten</code>: a tuple of booleans of whether each argument (including the function itself) is modified between the   forward and reverse pass (true if potentially modified between).</li></ul><p>Getters for the four type parameters are provided by <code>needs_primal</code>, <code>needs_shadow</code>, <code>width</code>, and <code>overwritten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L21-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.augmented_primal" href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">augmented_primal(::Config, func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Must return an <a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>AugmentedReturn</code></a> type.</p><ul><li>The primal must be the same type of the original return if <code>needs_primal(config)</code>, otherwise nothing.</li><li>The shadow must be nothing if needs_shadow(config) is false. If width is 1, the shadow should be the same type of the original return. If the width is greater than 1, the shadow should be NTuple{original return, width}.</li><li>The tape can be any type (including Nothing) and is preserved for the reverse call.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.forward" href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forward(func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Calculate the forward derivative. The first argument <code>func</code> is the callable for which the rule applies to. Either wrapped in a <a href="#EnzymeCore.Const"><code>Const</code></a>), or a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> if it is a closure. The second argument is the return type annotation, and all other arguments are the annotated function arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L10-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.inactive" href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inactive(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.inactive_noinl" href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inactive_noinl(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself, but do not prevent inlining of the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}" href="#EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}"><code>EnzymeCore.EnzymeRules.inactive_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inactive_type(::Type{Ty})</code></pre><p>Mark a particular type <code>Ty</code> as always being inactive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.noalias" href="#EnzymeCore.EnzymeRules.noalias"><code>EnzymeCore.EnzymeRules.noalias</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">noalias(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being a fresh allocation which does not alias any other  accessible memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeCore.EnzymeRules.reverse" href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(::Config, func::Annotation{typeof(f)}, dret::Active, tape, args::Annotation...)
reverse(::Config, func::Annotation{typeof(f)}, ::Type{&lt;:Annotation), tape, args::Annotation...)</code></pre><p>Takes gradient of derivative, activity annotation, and tape. If there is an active return dret is passed as Active{T} with the derivative of the active return val. Otherwise dret is passed as Type{Duplicated{T}}, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeCore/src/rules.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeTestUtils.ExprAndMsg" href="#EnzymeTestUtils.ExprAndMsg"><code>EnzymeTestUtils.ExprAndMsg</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A cunning hack to carry extra message along with the original expression in a test</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeTestUtils/src/output_control.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}" href="#EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.@test_msg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@test_msg msg condion kws...</code></pre><p>This is per <code>Test.@test condion kws...</code> except that if it fails it also prints the <code>msg</code>. If <code>msg==&quot;&quot;</code> then this is just like <code>@test</code>, nothing is printed</p><p><strong>Examles</strong></p><pre><code class="language-julia hljs">julia&gt; @test_msg &quot;It is required that the total is under 10&quot; sum(1:1000) &lt; 10;
Test Failed at REPL[1]:1
  Expression: sum(1:1000) &lt; 10
  Problem: It is required that the total is under 10
   Evaluated: 500500 &lt; 10
ERROR: There was an error during testing


julia&gt; @test_msg &quot;It is required that the total is under 10&quot; error(&quot;not working at all&quot;);
Error During Test at REPL[2]:1
  Test threw exception
  Expression: error(&quot;not working at all&quot;)
  Problem: It is required that the total is under 10
  &quot;not working at all&quot;
  Stacktrace:

julia&gt; a = &quot;&quot;;

julia&gt; @test_msg a sum(1:1000) &lt; 10;
  Test Failed at REPL[153]:1
    Expression: sum(1:1000) &lt; 10
     Evaluated: 500500 &lt; 10
  ERROR: There was an error during testing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeTestUtils/src/output_control.jl#L14-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}" href="#EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}"><code>EnzymeTestUtils.are_activities_compatible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are_activities_compatible(Tret, activities...) -&gt; Bool</code></pre><p>Return <code>true</code> if return activity type <code>Tret</code> and activity types <code>activities</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeTestUtils/src/compatible_activities.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}" href="#EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">test_forward(f, Activity, args...; kwargs...)</code></pre><p>Test <code>Enzyme.autodiff</code> of <code>f</code> in <code>Forward</code>-mode against finite differences.</p><p><code>f</code> has all constraints of the same argument passed to <code>Enzyme.autodiff</code>, with additional constraints:</p><ul><li>If it mutates one of its arguments, it <em>must</em> return that argument.</li></ul><p><strong>Arguments</strong></p><ul><li><code>Activity</code>: the activity of the return value of <code>f</code></li><li><code>args</code>: Each entry is either an argument to <code>f</code>, an activity type accepted by <code>autodiff</code>,   or a tuple of the form <code>(arg, Activity)</code>, where <code>Activity</code> is the activity type of   <code>arg</code>. If the activity type specified requires a tangent, a random tangent will be   automatically generated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rng::AbstractRNG</code>: The random number generator to use for generating random tangents.</li><li><code>fdm=FiniteDifferences.central_fdm(5, 1)</code>: The finite differences method to use.</li><li><code>fkwargs</code>: Keyword arguments to pass to <code>f</code>.</li><li><code>rtol</code>: Relative tolerance for <code>isapprox</code>.</li><li><code>atol</code>: Absolute tolerance for <code>isapprox</code>.</li><li><code>testset_name</code>: Name to use for a testset in which all tests are evaluated.</li></ul><p><strong>Examples</strong></p><p>Here we test a rule for a function of scalars. Because we don&#39;t provide an activity annotation for <code>y</code>, it is assumed to be <code>Const</code>.</p><pre><code class="language-julia hljs">using Enzyme, EnzymeTestUtils

x, y = randn(2)
for Tret in (Const, Duplicated, DuplicatedNoNeed), Tx in (Const, Duplicated)
    test_forward(*, Tret, (x, Tx), y)
end</code></pre><p>Here we test a rule for a function of an array in batch forward-mode:</p><pre><code class="language-julia hljs">x = randn(3)
y = randn()
for Tret in (Const, BatchDuplicated, BatchDuplicatedNoNeed),
    Tx in (Const, BatchDuplicated),
    Ty in (Const, BatchDuplicated)

    test_forward(*, Tret, (x, Tx), (y, Ty))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeTestUtils/src/test_forward.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}" href="#EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">test_reverse(f, Activity, args...; kwargs...)</code></pre><p>Test <code>Enzyme.autodiff_thunk</code> of <code>f</code> in <code>ReverseSplitWithPrimal</code>-mode against finite differences.</p><p><code>f</code> has all constraints of the same argument passed to <code>Enzyme.autodiff_thunk</code>, with additional constraints:</p><ul><li>If an <code>Array{&lt;:AbstractFloat}</code> appears in the input/output, then a reshaped version of it   may not also appear in the input/output.</li></ul><p><strong>Arguments</strong></p><ul><li><code>Activity</code>: the activity of the return value of <code>f</code>.</li><li><code>args</code>: Each entry is either an argument to <code>f</code>, an activity type accepted by <code>autodiff</code>,   or a tuple of the form <code>(arg, Activity)</code>, where <code>Activity</code> is the activity type of   <code>arg</code>. If the activity type specified requires a shadow, one will be automatically   generated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rng::AbstractRNG</code>: The random number generator to use for generating random tangents.</li><li><code>fdm=FiniteDifferences.central_fdm(5, 1)</code>: The finite differences method to use.</li><li><code>fkwargs</code>: Keyword arguments to pass to <code>f</code>.</li><li><code>rtol</code>: Relative tolerance for <code>isapprox</code>.</li><li><code>atol</code>: Absolute tolerance for <code>isapprox</code>.</li><li><code>testset_name</code>: Name to use for a testset in which all tests are evaluated.</li></ul><p><strong>Examples</strong></p><p>Here we test a rule for a function of scalars. Because we don&#39;t provide an activity annotation for <code>y</code>, it is assumed to be <code>Const</code>.</p><pre><code class="language-julia hljs">using Enzyme, EnzymeTestUtils

x = randn()
y = randn()
for Tret in (Const, Active), Tx in (Const, Active)
    test_reverse(*, Tret, (x, Tx), y)
end</code></pre><p>Here we test a rule for a function of an array in batch reverse-mode:</p><pre><code class="language-julia hljs">x = randn(3)
for Tret in (Const, Active), Tx in (Const, BatchDuplicated)
    test_reverse(prod, Tret, (x, Tx))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/lib/EnzymeTestUtils/src/test_reverse.jl#L20-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.fast_math!-Tuple{Any}" href="#Enzyme.API.fast_math!-Tuple{Any}"><code>Enzyme.API.fast_math!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fast_math!(val::Bool)</code></pre><p>Whether generated derivatives have fast math on or off, default on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L537-L541">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.inlineall!-Tuple{Any}" href="#Enzyme.API.inlineall!-Tuple{Any}"><code>Enzyme.API.inlineall!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inlineall!(val::Bool)</code></pre><p>Whether to inline all (non-recursive) functions generated by Julia within a  single compilation unit. This may improve Enzyme&#39;s ability to successfully differentiate code and improve performance of the original and generated  derivative program. It often, however, comes with an increase in compile time. This is off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L449-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.instname!-Tuple{Any}" href="#Enzyme.API.instname!-Tuple{Any}"><code>Enzyme.API.instname!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instname!(val::Bool)</code></pre><p>Whether to add a name to all LLVM values. This may be helpful for debugging generated programs, both primal and derivative. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L617-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.looseTypeAnalysis!-Tuple{Any}" href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>Enzyme.API.looseTypeAnalysis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">looseTypeAnalysis!(val::Bool)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. For example, a copy of Float32&#39;s requires a different derivative than a memcpy of Float64&#39;s, Ptr&#39;s, etc. In some cases Enzyme may not be able to deduce all the types necessary and throw an unknown type error. If this is the case, open an issue.  One can silence these issues by setting <code>looseTypeAnalysis!(true)</code> which tells  Enzyme to make its best guess. This will remove the error and allow differentiation to continue, however, it may produce incorrect results. Alternatively one can consider increasing the space of the evaluated type lattice which gives Enzyme more time to run a more thorough analysis through the use of <a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>maxtypeoffset!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L500-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.maxtypedepth!-Tuple{Any}" href="#Enzyme.API.maxtypedepth!-Tuple{Any}"><code>Enzyme.API.maxtypedepth!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxtypedepth!(val::Int)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. To ensure this analysis temrinates, it operates on a finite lattice of possible states. This function sets the maximum depth into a type that Enzyme will consider. A smaller value will cause type analysis to run faster, but may result in some necessary types not being found and result in unknown type errors. A larger value may result in unknown type errors being resolved by searching a larger space, but may run longer. The default setting is 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L481-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.maxtypeoffset!-Tuple{Any}" href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>Enzyme.API.maxtypeoffset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxtypeoffset!(val::Int)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. To ensure this analysis temrinates, it operates on a finite lattice of possible states. This function sets the maximum offset into a type that Enzyme will consider. A smaller value will cause type analysis to run faster, but may result in some necessary types not being found and result in unknown type errors. A larger value may result in unknown type errors being resolved by searching a larger space, but may run longer. The default setting is 512.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L464-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.memmove_warning!-Tuple{Any}" href="#Enzyme.API.memmove_warning!-Tuple{Any}"><code>Enzyme.API.memmove_warning!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">memmove_warning!(val::Bool)</code></pre><p>Whether to issue a warning when differentiating memmove. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L629-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printactivity!-Tuple{Any}" href="#Enzyme.API.printactivity!-Tuple{Any}"><code>Enzyme.API.printactivity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printactivity!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) a log of all decisions made during Activity Analysis (the analysis which determines what values/instructions are differentiated). This may be useful for debugging MixedActivity errors, correctness, and performance errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L401-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printall!-Tuple{Any}" href="#Enzyme.API.printall!-Tuple{Any}"><code>Enzyme.API.printall!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printall!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) the LLVM function being differentiated, as well as all generated derivatives immediately after running Enzyme (but prior to any other optimizations). Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L416-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printdiffuse!-Tuple{Any}" href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>Enzyme.API.printdiffuse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printdiffuse!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) information about each LLVM value – specifically whether it and its shadow is required for computing the derivative. In contrast to <a href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>printunnecessary!</code></a>, this flag prints debug log for the analysis which determines for each value and shadow value, whether it can find a user which would require it to be kept around (rather than being deleted). This is prior to any cache optimizations and a debug log of Differential Use Analysis. This may be helpful for debugging caching, phi node deletion, performance, and other errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L366-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printperf!-Tuple{Any}" href="#Enzyme.API.printperf!-Tuple{Any}"><code>Enzyme.API.printperf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printperf!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) performance information about generated derivative programs. It will provide debug information that warns why particular values are cached for the reverse pass, and thus require additional computation/storage. This is particularly helpful for debugging derivatives which OOM or otherwise run slow. ff by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L350-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printtype!-Tuple{Any}" href="#Enzyme.API.printtype!-Tuple{Any}"><code>Enzyme.API.printtype!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printtype!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) a log of all decisions made during Type Analysis (the analysis which Enzyme determines the type of all values in the program). This may be useful for debugging correctness errors, illegal type analysis errors, insufficient type information errors, correctness, and performance errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L385-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.printunnecessary!-Tuple{Any}" href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>Enzyme.API.printunnecessary!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printunnecessary!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) information about each LLVM value – specifically whether it and its shadow is required for computing the derivative. In contrast to <a href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>printdiffuse!</code></a>, this flag prints the final results after running cache optimizations such as minCut (see Recompute vs Cache Heuristics from <a href="https://c.wsmoses.com/papers/EnzymeGPU.pdf">this paper</a> and slides 31-33 from <a href="https://c.wsmoses.com/presentations/enzyme-sc.pdf">this presentation</a>) for a description of the caching algorithm. This may be helpful for debugging caching, phi node deletion, performance, and other errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.runtimeActivity!-Tuple{Bool}" href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>Enzyme.API.runtimeActivity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runtimeActivity!(val::Bool)</code></pre><p>Enzyme runs an activity analysis which deduces which values, instructions, etc are necessary to be differentiated and therefore involved in the differentiation procedure. This runs at compile time. However, there may be implementation flaws in this analysis that means that Enzyme cannot deduce that an inactive (const) value is actually const. Alternatively, there may be some data which is conditionally active, depending on which runtime branch is taken. In these cases Enzyme conservatively presumes the value is active.</p><p>However, in certain cases, an insufficiently aggressive activity analysis may result in derivative errors – for example by mistakenly using the primal (const) argument and mistaking it for the duplicated shadow. As a result this may result in incorrect results, or accidental updates to the primal.</p><p>This flag enables runntime activity which tells all load/stores to check at runtime whether the value they are updating is indeed active (in addition to the compile-time activity analysis). This will remedy these such errors, but at a performance penalty of performing such checks.</p><p>It is on the Enzyme roadmap to add a PotentiallyDuplicated style activity, in addition to the current Const and Duplicated styles that will disable the need for this, which does  not require the check when a value is guaranteed active, but still supports runtime-based activity information.</p><p>This function takes an argument to set the runtime activity value, true means it is on, and false means off. By default it is off.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L559-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.runtimeActivity-Tuple{}" href="#Enzyme.API.runtimeActivity-Tuple{}"><code>Enzyme.API.runtimeActivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">runtimeActivity()</code></pre><p>Gets the current value of the runtime activity. See <a href="#Enzyme.API.runtimeActivity!-Tuple{Bool}"><code>runtimeActivity!</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L593-L598">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.strictAliasing!-Tuple{Any}" href="#Enzyme.API.strictAliasing!-Tuple{Any}"><code>Enzyme.API.strictAliasing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strictAliasing!(val::Bool)</code></pre><p>Whether Enzyme&#39;s type analysis will assume strict aliasing semantics. When strict aliasing semantics are on (the default), Enzyme can propagate type information up through conditional branches. This may lead to illegal type errors when analyzing code with unions. Disabling strict aliasing will enable these union types to be correctly analyzed. However, it may lead to some errors that sufficient type information cannot be deduced. One can turn these insufficient type information errors into to warnings by calling <a href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>looseTypeAnalysis!</code></a><code>(true)</code> which tells Enzyme to use its best guess in such scenarios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L520-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.strong_zero!-Tuple{Any}" href="#Enzyme.API.strong_zero!-Tuple{Any}"><code>Enzyme.API.strong_zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strong_zero!(val::Bool)</code></pre><p>Whether to enforce multiplication by zero as enforcing a zero result even if multiplying against a NaN or infinity. Necessary for some programs in which a value has a zero derivative since it is unused, even if it has an otherwise infinite or nan derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L547-L553">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Enzyme.API.typeWarning!-Tuple{Any}" href="#Enzyme.API.typeWarning!-Tuple{Any}"><code>Enzyme.API.typeWarning!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typeWarning!(val::Bool)</code></pre><p>Whether to print a warning when Type Analysis learns informatoin about a value&#39;s type which cannot be represented in the current size of the lattice. See <a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>maxtypeoffset!</code></a> for more information. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/957f082b1a11c1eb237712a6e266c9bb18dac3d3/src/api.jl#L604-L611">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« FAQ</a><a class="docs-footer-nextpage" href="../dev_docs/">For developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 9 August 2024 12:17">Friday 9 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
