<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · Enzyme.jl</title><meta name="title" content="API reference · Enzyme.jl"/><meta property="og:title" content="API reference · Enzyme.jl"/><meta property="twitter:title" content="API reference · Enzyme.jl"/><meta name="description" content="Documentation for Enzyme.jl."/><meta property="og:description" content="Documentation for Enzyme.jl."/><meta property="twitter:description" content="Documentation for Enzyme.jl."/><meta property="og:url" content="https://enzyme.mit.edu/julia/api/"/><meta property="twitter:url" content="https://enzyme.mit.edu/julia/api/"/><link rel="canonical" href="https://enzyme.mit.edu/julia/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="https://plausible.io/js/plausible.js" data-domain="enzyme.mit.edu" defer></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Enzyme.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Enzyme.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/autodiff/">Basics</a></li><li><a class="tocitem" href="../generated/box/">Box model</a></li><li><a class="tocitem" href="../generated/custom_rule/">Custom rules</a></li></ul></li><li><span class="tocitem">Notebooks</span><ul><li><a class="tocitem" href="../notebooks/ignore_derivatives/">Ignore derivatives</a></li></ul></li><li><a class="tocitem" href="../faq/">FAQ</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Types-and-constants"><span>Types and constants</span></a></li><li><a class="tocitem" href="#Functions-and-macros"><span>Functions and macros</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><span class="tocitem">Advanced</span><ul><li><a class="tocitem" href="../dev_docs/">For developers</a></li><li><a class="tocitem" href="../internal_api/">Internal API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EnzymeAD/Enzyme.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="Types-and-constants"><a class="docs-heading-anchor" href="#Types-and-constants">Types and constants</a><a id="Types-and-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-constants" title="Permalink"></a></h2><ul><li><a href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a></li><li><a href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a></li><li><a href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a></li><li><a href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a></li><li><a href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.BatchMixedDuplicated"><code>EnzymeCore.BatchMixedDuplicated</code></a></li><li><a href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a></li><li><a href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a></li><li><a href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a></li><li><a href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a></li><li><a href="#EnzymeCore.InlineABI"><code>EnzymeCore.InlineABI</code></a></li><li><a href="#EnzymeCore.MixedDuplicated"><code>EnzymeCore.MixedDuplicated</code></a></li><li><a href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a></li><li><a href="#EnzymeCore.NonGenABI"><code>EnzymeCore.NonGenABI</code></a></li><li><a href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a></li><li><a href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a></li><li><a href="#EnzymeCore.Forward"><code>EnzymeCore.Forward</code></a></li><li><a href="#EnzymeCore.ForwardWithPrimal"><code>EnzymeCore.ForwardWithPrimal</code></a></li><li><a href="#EnzymeCore.Reverse"><code>EnzymeCore.Reverse</code></a></li><li><a href="#EnzymeCore.ReverseHolomorphic"><code>EnzymeCore.ReverseHolomorphic</code></a></li><li><a href="#EnzymeCore.ReverseHolomorphicWithPrimal"><code>EnzymeCore.ReverseHolomorphicWithPrimal</code></a></li><li><a href="#EnzymeCore.ReverseSplitNoPrimal"><code>EnzymeCore.ReverseSplitNoPrimal</code></a></li><li><a href="#EnzymeCore.ReverseSplitWithPrimal"><code>EnzymeCore.ReverseSplitWithPrimal</code></a></li><li><a href="#EnzymeCore.ReverseWithPrimal"><code>EnzymeCore.ReverseWithPrimal</code></a></li><li><a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a></li><li><a href="#EnzymeCore.EnzymeRules.FwdConfig"><code>EnzymeCore.EnzymeRules.FwdConfig</code></a></li><li><a href="#EnzymeCore.EnzymeRules.RevConfig"><code>EnzymeCore.EnzymeRules.RevConfig</code></a></li><li><a href="#EnzymeTestUtils.ExprAndMsg"><code>EnzymeTestUtils.ExprAndMsg</code></a></li><li><a href="../internal_api/#Enzyme.Compiler.EnzymeError"><code>Enzyme.Compiler.EnzymeError</code></a></li><li><a href="#Enzyme.Compiler.CheckNan"><code>Enzyme.Compiler.CheckNan</code></a></li></ul><h2 id="Functions-and-macros"><a class="docs-heading-anchor" href="#Functions-and-macros">Functions and macros</a><a id="Functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-macros" title="Permalink"></a></h2><ul><li><a href="#Enzyme.@import_frule-Tuple"><code>Enzyme.@import_frule</code></a></li><li><a href="#Enzyme.@import_rrule-Tuple"><code>Enzyme.@import_rrule</code></a></li><li><a href="#Enzyme.batch_call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><code>Enzyme.batch_call_same_with_inverted_arg_if_active!</code></a></li><li><a href="#Enzyme.call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><code>Enzyme.call_same_with_inverted_arg_if_active!</code></a></li><li><a href="#Enzyme.create_fresh_codeinfo-NTuple{5, Any}"><code>Enzyme.create_fresh_codeinfo</code></a></li><li><a href="#Enzyme.gradient-Union{Tuple{N}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{ty_0}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, F, ty_0, Vararg{Any, N}}} where {F, ty_0, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten, N}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient-Union{Tuple{N}, Tuple{ty_0}, Tuple{ST}, Tuple{CS}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{ForwardMode{ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, F, ty_0, Vararg{Any, N}}} where {F, ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero, CS, ST, ty_0, N}"><code>Enzyme.gradient</code></a></li><li><a href="#Enzyme.gradient!-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{X}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, X, F, X}} where {X&lt;:AbstractArray, F, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>Enzyme.gradient!</code></a></li><li><a href="../internal_api/#Enzyme.guess_activity-Union{Tuple{T}, Tuple{Type{T}, Mode}} where T"><code>Enzyme.guess_activity</code></a></li><li><a href="#Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}"><code>Enzyme.hvp</code></a></li><li><a href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>Enzyme.hvp!</code></a></li><li><a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>Enzyme.hvp_and_gradient!</code></a></li><li><a href="#Enzyme.jacobian-Tuple{ForwardMode, Vararg{Any}}"><code>Enzyme.jacobian</code></a></li><li><a href="#Enzyme.jacobian-Union{Tuple{CT}, Tuple{OutType}, Tuple{Nargs}, Tuple{F}, Tuple{ReverseMode, F, Vararg{Any, Nargs}}} where {F, Nargs, OutType, CT}"><code>Enzyme.jacobian</code></a></li><li><a href="#Enzyme.typetree"><code>Enzyme.typetree</code></a></li><li><a href="#Enzyme.unsafe_to_pointer"><code>Enzyme.unsafe_to_pointer</code></a></li><li><a href="#EnzymeCore.Combined-Union{Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.Combined</code></a></li><li><a href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.NoPrimal</code></a></li><li><a href="#EnzymeCore.ReverseSplitModified-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{MBO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{MB}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.ReverseSplitModified</code></a></li><li><a href="#EnzymeCore.ReverseSplitWidth-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{WidthO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, WidthO, MB, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{Width}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, WidthO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.ReverseSplitWidth</code></a></li><li><a href="#EnzymeCore.Split-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}, Val{ShadowInit}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.Split</code></a></li><li><a href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.WithPrimal</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:Mode, Nargs}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A0}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, RuntimeActivity, StrongZero, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:Mode, Nargs}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff-Union{Tuple{MMode}, Tuple{Nargs}, Tuple{A}, Tuple{Function, MMode, Type{A}, Vararg{Annotation, Nargs}}} where {A&lt;:Annotation, Nargs, MMode&lt;:Mode}"><code>EnzymeCore.autodiff</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, Nargs, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, RABI&lt;:EnzymeCore.ABI, Holomorphic, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_deferred</code></a></li><li><a href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ShadowInit}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, ShadowInit}"><code>EnzymeCore.autodiff_deferred_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{FA}, Type{A0}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, ShadowInit, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_thunk</code></a></li><li><a href="#EnzymeCore.clear_err_if_func_written"><code>EnzymeCore.clear_err_if_func_written</code></a></li><li><a href="#EnzymeCore.clear_runtime_activity"><code>EnzymeCore.clear_runtime_activity</code></a></li><li><a href="#EnzymeCore.clear_strong_zero"><code>EnzymeCore.clear_strong_zero</code></a></li><li><a href="#EnzymeCore.compiler_job_from_backend"><code>EnzymeCore.compiler_job_from_backend</code></a></li><li><a href="#EnzymeCore.ignore_derivatives-Tuple{T} where T"><code>EnzymeCore.ignore_derivatives</code></a></li><li><a href="#EnzymeCore.make_zero"><code>EnzymeCore.make_zero</code></a></li><li><a href="#EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}"><code>EnzymeCore.make_zero</code></a></li><li><a href="#EnzymeCore.make_zero!"><code>EnzymeCore.make_zero!</code></a></li><li><a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>EnzymeCore.needs_primal</code></a></li><li><a href="#EnzymeCore.needs_primal-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, NeedsPrimal, NeedsShadow} where {NeedsShadow, Width}}, Tuple{NeedsPrimal}} where NeedsPrimal"><code>EnzymeCore.needs_primal</code></a></li><li><a href="#EnzymeCore.remake_zero!"><code>EnzymeCore.remake_zero!</code></a></li><li><a href="#EnzymeCore.runtime_activity-Union{Tuple{Mode{&lt;:Any, &lt;:Any, RuntimeActivity}}, Tuple{RuntimeActivity}} where RuntimeActivity"><code>EnzymeCore.runtime_activity</code></a></li><li><a href="#EnzymeCore.set_abi"><code>EnzymeCore.set_abi</code></a></li><li><a href="#EnzymeCore.set_err_if_func_written"><code>EnzymeCore.set_err_if_func_written</code></a></li><li><a href="#EnzymeCore.set_runtime_activity"><code>EnzymeCore.set_runtime_activity</code></a></li><li><a href="#EnzymeCore.set_strong_zero"><code>EnzymeCore.set_strong_zero</code></a></li><li><a href="#EnzymeCore.strong_zero-Union{Tuple{Mode{&lt;:Any, &lt;:Any, &lt;:Any, StrongZero}}, Tuple{StrongZero}} where StrongZero"><code>EnzymeCore.strong_zero</code></a></li><li><a href="#EnzymeCore.within_autodiff-Tuple{}"><code>EnzymeCore.within_autodiff</code></a></li><li><a href="#EnzymeCore.EnzymeRules.@easy_rule-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeCore.EnzymeRules.@easy_rule</code></a></li><li><a href="#EnzymeCore.EnzymeRules._constrain_and_name-Tuple{Expr}"><code>EnzymeCore.EnzymeRules._constrain_and_name</code></a></li><li><a href="#EnzymeCore.EnzymeRules._just_name-Tuple{Expr}"><code>EnzymeCore.EnzymeRules._just_name</code></a></li><li><a href="#EnzymeCore.EnzymeRules._normalize_scalarrules_macro_input-Tuple{Any, Any, Any}"><code>EnzymeCore.EnzymeRules._normalize_scalarrules_macro_input</code></a></li><li><a href="#EnzymeCore.EnzymeRules._unconstrain-Tuple{Symbol}"><code>EnzymeCore.EnzymeRules._unconstrain</code></a></li><li><a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a></li><li><a href="#EnzymeCore.EnzymeRules.augmented_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.RevConfig}, Type{&lt;:Annotation}}"><code>EnzymeCore.EnzymeRules.augmented_rule_return_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a></li><li><a href="#EnzymeCore.EnzymeRules.forward_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.FwdConfig}, Type{&lt;:Annotation}}"><code>EnzymeCore.EnzymeRules.forward_rule_return_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_arg"><code>EnzymeCore.EnzymeRules.inactive_arg</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_kwarg"><code>EnzymeCore.EnzymeRules.inactive_kwarg</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a></li><li><a href="#EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}"><code>EnzymeCore.EnzymeRules.inactive_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.multiply_fwd_into"><code>EnzymeCore.EnzymeRules.multiply_fwd_into</code></a></li><li><a href="#EnzymeCore.EnzymeRules.multiply_rev_into"><code>EnzymeCore.EnzymeRules.multiply_rev_into</code></a></li><li><a href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>EnzymeCore.EnzymeRules.needs_shadow</code></a></li><li><a href="#EnzymeCore.EnzymeRules.noalias"><code>EnzymeCore.EnzymeRules.noalias</code></a></li><li><a href="#EnzymeCore.EnzymeRules.overwritten-Union{Tuple{EnzymeCore.EnzymeRules.RevConfigWidth{&lt;:Any, var&quot;#s7&quot;, var&quot;#s3&quot;, Overwritten} where {var&quot;#s7&quot;, var&quot;#s3&quot;}}, Tuple{Overwritten}} where Overwritten"><code>EnzymeCore.EnzymeRules.overwritten</code></a></li><li><a href="#EnzymeCore.EnzymeRules.primal_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><code>EnzymeCore.EnzymeRules.primal_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a></li><li><a href="#EnzymeCore.EnzymeRules.shadow_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><code>EnzymeCore.EnzymeRules.shadow_type</code></a></li><li><a href="#EnzymeCore.EnzymeRules.uses_symbol-Tuple{Any, Symbol}"><code>EnzymeCore.EnzymeRules.uses_symbol</code></a></li><li><a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>EnzymeCore.EnzymeRules.width</code></a></li><li><a href="#EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.@test_msg</code></a></li><li><a href="#EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}"><code>EnzymeTestUtils.are_activities_compatible</code></a></li><li><a href="#EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_forward</code></a></li><li><a href="#EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_reverse</code></a></li><li><a href="#Enzyme.API.fast_math!-Tuple{Any}"><code>Enzyme.API.fast_math!</code></a></li><li><a href="#Enzyme.API.inlineall!-Tuple{Any}"><code>Enzyme.API.inlineall!</code></a></li><li><a href="#Enzyme.API.instname!-Tuple{Any}"><code>Enzyme.API.instname!</code></a></li><li><a href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>Enzyme.API.looseTypeAnalysis!</code></a></li><li><a href="#Enzyme.API.maxtypedepth!-Tuple{Any}"><code>Enzyme.API.maxtypedepth!</code></a></li><li><a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>Enzyme.API.maxtypeoffset!</code></a></li><li><a href="#Enzyme.API.memmove_warning!-Tuple{Any}"><code>Enzyme.API.memmove_warning!</code></a></li><li><a href="#Enzyme.API.printactivity!-Tuple{Any}"><code>Enzyme.API.printactivity!</code></a></li><li><a href="#Enzyme.API.printall!-Tuple{Any}"><code>Enzyme.API.printall!</code></a></li><li><a href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>Enzyme.API.printdiffuse!</code></a></li><li><a href="#Enzyme.API.printperf!-Tuple{Any}"><code>Enzyme.API.printperf!</code></a></li><li><a href="#Enzyme.API.printtype!-Tuple{Any}"><code>Enzyme.API.printtype!</code></a></li><li><a href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>Enzyme.API.printunnecessary!</code></a></li><li><a href="#Enzyme.API.strictAliasing!-Tuple{Any}"><code>Enzyme.API.strictAliasing!</code></a></li><li><a href="#Enzyme.API.typeWarning!-Tuple{Any}"><code>Enzyme.API.typeWarning!</code></a></li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Enzyme.@import_frule-Tuple"><a class="docstring-binding" href="#Enzyme.@import_frule-Tuple"><code>Enzyme.@import_frule</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">import_frule(::fn, tys...)</code></pre><p>Automatically import a <code>ChainRulesCore.frule</code> as a custom forward mode <code>EnzymeRule</code>. When called in batch mode, this will end up calling the primal multiple times, which may result in incorrect behavior if the function mutates, and slow code, always. Importing the rule from <code>ChainRules</code> is also likely to be slower than writing your own rule, and may also be slower than not having a rule at all.</p><p>Use with caution.</p><pre><code class="language-julia hljs">Enzyme.@import_frule(typeof(Base.sort), Any);

x=[1.0, 2.0, 0.0]; dx=[0.1, 0.2, 0.3]; ddx = [0.01, 0.02, 0.03];

Enzyme.autodiff(Forward, sort, Duplicated, BatchDuplicated(x, (dx,ddx)))
Enzyme.autodiff(Forward, sort, DuplicatedNoNeed, BatchDuplicated(x, (dx,ddx)))
Enzyme.autodiff(Forward, sort, DuplicatedNoNeed, BatchDuplicated(x, (dx,)))
Enzyme.autodiff(Forward, sort, Duplicated, BatchDuplicated(x, (dx,)))

# output

(var&quot;1&quot; = [0.0, 1.0, 2.0], var&quot;2&quot; = (var&quot;1&quot; = [0.3, 0.1, 0.2], var&quot;2&quot; = [0.03, 0.01, 0.02]))
(var&quot;1&quot; = (var&quot;1&quot; = [0.3, 0.1, 0.2], var&quot;2&quot; = [0.03, 0.01, 0.02]),)
(var&quot;1&quot; = [0.3, 0.1, 0.2],)
(var&quot;1&quot; = [0.0, 1.0, 2.0], var&quot;2&quot; = [0.3, 0.1, 0.2])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L1514-L1542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.@import_rrule-Tuple"><a class="docstring-binding" href="#Enzyme.@import_rrule-Tuple"><code>Enzyme.@import_rrule</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">import_rrule(::fn, tys...)</code></pre><p>Automatically import a <code>ChainRules.rrule</code> as a custom reverse mode EnzymeRule. When called in batch mode, this will end up calling the primal multiple times which results in slower code. This macro assumes that the underlying function to be imported is read-only, and returns a Duplicated or Const object. This macro also assumes that the inputs permit a <code>.+=</code> operation and that the output has a valid <code>Enzyme.make_zero</code> function defined. It also assumes that <code>overwritten(x)</code> accurately describes if there is any non-preserved data from forward to reverse, not just the outermost data structure being overwritten as provided by the specification.</p><p>Finally, this macro falls back to almost always caching all of the inputs, even if it may not be needed for the derivative computation.</p><p>As a result, this auto importer is also likely to be slower than writing your own rule, and may also be slower than not having a rule at all.</p><p>Use with caution.</p><pre><code class="language-julia hljs">Enzyme.@import_rrule(typeof(Base.sort), Any);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L1549-L1570">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.batch_call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><a class="docstring-binding" href="#Enzyme.batch_call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><code>Enzyme.batch_call_same_with_inverted_arg_if_active!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Helper function for llvm-level rule generation. Will call call<em>same</em>with<em>inverted</em>arg<em>if</em>active with corresponding extracted batches if width &gt; 1, otherwise it will call it once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/gradientutils.jl#L313-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><a class="docstring-binding" href="#Enzyme.call_same_with_inverted_arg_if_active!-Tuple{LLVM.IRBuilder, Enzyme.GradientUtils, LLVM.CallInst, Vector{&lt;:LLVM.Value}, Vector{Enzyme.API.CValueType}, Bool}"><code>Enzyme.call_same_with_inverted_arg_if_active!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Helper function for llvm-level rule generation. Will call the same function (and optional postprocessing), if the argument at index <code>cmpidx</code> isn&#39;t active. This takes into account runtime activity as a reason the value may not be active. </p><p>If postprocess_const is set, the original function will always be called, but the postprocessing will be conditionally gated as follows.</p><p>If the relevant input is active (and verified by runtime activity),      postprocess(B, result, args) will run as normal Otherwise     postprocess_const(B, result, args) will run</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/gradientutils.jl#L196-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.create_fresh_codeinfo-NTuple{5, Any}"><a class="docstring-binding" href="#Enzyme.create_fresh_codeinfo-NTuple{5, Any}"><code>Enzyme.create_fresh_codeinfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_fresh_codeinfo(fn, source, world)</code></pre><p>Create a fresh <code>Core.CodeInfo</code> for a generated function <code>fn</code> with source location <code>source</code> and world age <code>world</code>. Callers are responsible for setting <code>ci.edges</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/utils.jl#L280-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.gradient!-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{X}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, X, F, X}} where {X&lt;:AbstractArray, F, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><a class="docstring-binding" href="#Enzyme.gradient!-Union{Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{X}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, X, F, X}} where {X&lt;:AbstractArray, F, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>Enzyme.gradient!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient!(::ReverseMode, dx, f, x)</code></pre><p>Compute the gradient of an array-input function <code>f</code> using reverse mode, storing the derivative result in an existing array <code>dx</code>. Both <code>x</code> and <code>dx</code> must be <code>Array</code>s of the same type.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

dx = [0.0, 0.0]
gradient!(Reverse, dx, f, [2.0, 3.0])

# output
([3.0, 2.0],)</code></pre><pre><code class="language-julia hljs">dx = [0.0, 0.0]
gradient!(ReverseWithPrimal, dx, f, [2.0, 3.0])

# output
(derivs = ([3.0, 2.0],), val = 6.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L377-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.gradient-Union{Tuple{N}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{ty_0}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, F, ty_0, Vararg{Any, N}}} where {F, ty_0, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten, N}"><a class="docstring-binding" href="#Enzyme.gradient-Union{Tuple{N}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{ty_0}, Tuple{F}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, F, ty_0, Vararg{Any, N}}} where {F, ty_0, ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten, N}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(::ReverseMode, f, args...)</code></pre><p>Compute the gradient of a real-valued function <code>f</code> using reverse mode. For each differentiable argument, this function will allocate and return new derivative object, returning a tuple of derivatives for each argument. If an argument is not differentiable, the element of the returned tuple with be nothing.</p><p>In reverse mode (here), the derivatives will be the same type as the original argument.</p><p>This is a structure gradient. For a struct <code>x</code> it returns another instance of the same type, whose fields contain the components of the gradient. In the result, <code>grad.a</code> contains <code>∂f/∂x.a</code> for any differential <code>x.a</code>, while <code>grad.c == x.c</code> for other types.</p><p>Examples:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

grad = gradient(Reverse, f, [2.0, 3.0])

# output
([3.0, 2.0],)</code></pre><pre><code class="language-julia hljs">grad = gradient(Reverse, only ∘ f, (a = 2.0, b = [3.0], c = &quot;str&quot;))

# output

((a = 3.0, b = [2.0], c = &quot;str&quot;),)</code></pre><pre><code class="language-julia hljs">mul(x, y) = x[1]*y[1]

grad = gradient(Reverse, mul, [2.0], [3.0])

# output
([3.0], [2.0])</code></pre><pre><code class="language-julia hljs">
grad = gradient(Reverse, mul, [2.0], Const([3.0]))

# output
([3.0], nothing)</code></pre><p>If passing a mode that returns the primal (e.g. ReverseWithPrimal), the return type will instead be a tuple where the first element contains the derivatives, and the second element contains the result of the original computation.</p><pre><code class="language-julia hljs">
grad = gradient(ReverseWithPrimal, f, [2.0, 3.0])

# output
(derivs = ([3.0, 2.0],), val = 6.0)</code></pre><pre><code class="language-julia hljs">
grad = gradient(ReverseWithPrimal, mul, [2.0], [3.0])

# output
(derivs = ([3.0], [2.0]), val = 6.0)</code></pre><pre><code class="language-julia hljs">grad = gradient(ReverseWithPrimal, mul, [2.0], Const([3.0]))

# output
(derivs = ([3.0], nothing), val = 6.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L197-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.gradient-Union{Tuple{N}, Tuple{ty_0}, Tuple{ST}, Tuple{CS}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{ForwardMode{ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, F, ty_0, Vararg{Any, N}}} where {F, ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero, CS, ST, ty_0, N}"><a class="docstring-binding" href="#Enzyme.gradient-Union{Tuple{N}, Tuple{ty_0}, Tuple{ST}, Tuple{CS}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{ABI}, Tuple{ReturnPrimal}, Tuple{F}, Tuple{ForwardMode{ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, F, ty_0, Vararg{Any, N}}} where {F, ReturnPrimal, ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero, CS, ST, ty_0, N}"><code>Enzyme.gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gradient(::ForwardMode, f, x; shadows=onehot(x), chunk=nothing)</code></pre><p>Compute the gradient of an array-input function <code>f</code> using forward mode. The optional keyword argument <code>shadow</code> is a vector of one-hot vectors of type <code>x</code> which are used to forward-propagate into the return. For performance reasons, this should be computed once, outside the call to <code>gradient</code>, rather than within this call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = x[1]*x[2]

gradient(Forward, f, [2.0, 3.0])

# output

([3.0, 2.0],)</code></pre><pre><code class="language-julia hljs">gradient(ForwardWithPrimal, f, [2.0, 3.0])

# output
(derivs = ([3.0, 2.0],), val = 6.0)</code></pre><pre><code class="language-julia hljs">gradient(Forward, f, [2.0, 3.0]; chunk=Val(1))

# output

([3.0, 2.0],)</code></pre><pre><code class="language-julia hljs">gradient(ForwardWithPrimal, f, [2.0, 3.0]; chunk=Val(1))

# output
(derivs = ([3.0, 2.0],), val = 6.0)</code></pre><p>For functions which return an AbstractArray or scalar, this function will return an AbstractArray whose shape is <code>(size(output)..., size(input)...)</code>. No guarantees are presently made about the type of the AbstractArray returned by this function (which may or may not be the same as the input AbstractArray if provided).</p><p>For functions who return other types, this function will retun an AbstractArray of shape <code>size(input)</code> of values of the output type. </p><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = gradient(Forward, f, [2.0, 3.0, 4.0])

# output
([3.0 2.0 0.0; 0.0 1.0 1.0],)</code></pre><p>This function supports multiple arguments and computes the gradient with respect to each</p><pre><code class="language-julia hljs">mul(x, y) = x[1]*y[2] + x[2]*y[1]

gradient(Forward, mul, [2.0, 3.0], [2.7, 3.1])

# output

([3.1, 2.7], [3.0, 2.0])</code></pre><p>This includes the ability to mark some arguments as <code>Const</code> if its derivative is not needed, returning nothing in the corresponding derivative map.</p><pre><code class="language-julia hljs">gradient(Forward, mul, [2.0, 3.0], Const([2.7, 3.1]))

# output

([3.1, 2.7], nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L505-L585">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><a class="docstring-binding" href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>Enzyme.hvp!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hvp!(res::X, f::F, x::X, v::X) where {F, X}</code></pre><p>Compute an in-place Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code>. The result will be stored into <code>res</code>. The function still allocates and zero&#39;s a buffer to store the intermediate gradient, which is not returned to the user.</p><p>In other words, compute res .= hessian(f)(x) * v</p><p>See <a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>hvp_and_gradient!</code></a> for a function to compute both the hvp and the gradient in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

res = Vector{Float64}(undef, 2)
hvp!(res, f, [2.0, 3.0], [5.0, 2.7])

res
# output
2-element Vector{Float64}:
 19.6926882637302
 16.201003759768003</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L1285-L1310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}"><a class="docstring-binding" href="#Enzyme.hvp-Union{Tuple{X}, Tuple{F}, Tuple{F, X, X}} where {F, X}"><code>Enzyme.hvp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hvp(f::F, x::X, v::X) where {F, X}</code></pre><p>Compute the Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code>.</p><p>In other words, compute hessian(f)(x) * v</p><p>See <a href="#Enzyme.hvp!-Union{Tuple{X}, Tuple{F}, Tuple{X, F, X, X}} where {F, X}"><code>hvp!</code></a> for a version which stores the result in an existing buffer and also <a href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>hvp_and_gradient!</code></a> for a function to compute both the hvp and the gradient in a single call.</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

hvp(f, [2.0, 3.0], [5.0, 2.7])

# output
2-element Vector{Float64}:
 19.6926882637302
 16.201003759768003</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L1256-L1277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><a class="docstring-binding" href="#Enzyme.hvp_and_gradient!-Union{Tuple{X}, Tuple{F}, Tuple{X, X, F, X, X}} where {F, X}"><code>Enzyme.hvp_and_gradient!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hvp_and_gradient!(res::X, grad::X, f::F, x::X, v::X) where {F, X}</code></pre><p>Compute an in-place Hessian-vector product of an array-input scalar-output function <code>f</code>, as evaluated at <code>x</code> times the vector <code>v</code> as well as the gradient, storing the gradient into <code>grad</code>. Both the hessian vector product and the gradient can be computed together more efficiently than computing them separately.</p><p>The result will be stored into <code>res</code>. The gradient will be stored into <code>grad</code>.</p><p>In other words, compute res .= hessian(f)(x) * v  and grad .= gradient(Reverse, f)(x)</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = sin(x[1] * x[2])

res = Vector{Float64}(undef, 2)
grad = Vector{Float64}(undef, 2)
hvp_and_gradient!(res, grad, f, [2.0, 3.0], [5.0, 2.7])

res
grad
# output
2-element Vector{Float64}:
 2.880510859951098
 1.920340573300732</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L1326-L1353">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.jacobian-Tuple{ForwardMode, Vararg{Any}}"><a class="docstring-binding" href="#Enzyme.jacobian-Tuple{ForwardMode, Vararg{Any}}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian(::ForwardMode, args...; kwargs...)</code></pre><p>Equivalent to gradient(::ForwardMode, args...; kwargs...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L789-L793">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.jacobian-Union{Tuple{CT}, Tuple{OutType}, Tuple{Nargs}, Tuple{F}, Tuple{ReverseMode, F, Vararg{Any, Nargs}}} where {F, Nargs, OutType, CT}"><a class="docstring-binding" href="#Enzyme.jacobian-Union{Tuple{CT}, Tuple{OutType}, Tuple{Nargs}, Tuple{F}, Tuple{ReverseMode, F, Vararg{Any, Nargs}}} where {F, Nargs, OutType, CT}"><code>Enzyme.jacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">jacobian(::ReverseMode, f, x; n_outs=nothing, chunk=nothing)
jacobian(::ReverseMode, f, x)</code></pre><p>Compute the jacobian of a array-output function <code>f</code> using (potentially vector) reverse mode. The <code>chunk</code> argument optionally denotes the chunk size to use and <code>n_outs</code> optionally denotes the shape of the array returned by <code>f</code> (e.g <code>size(f(x))</code>).</p><p>Example:</p><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

jacobian(Reverse, f, [2.0, 3.0, 4.0])

# output
([3.0 2.0 0.0; 0.0 1.0 1.0],)</code></pre><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = jacobian(ReverseWithPrimal, f, [2.0, 3.0, 4.0])

# output
(derivs = ([3.0 2.0 0.0; 0.0 1.0 1.0],), val = [6.0, 7.0])</code></pre><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = jacobian(Reverse, f, [2.0, 3.0, 4.0], n_outs=Val((2,)))

# output
([3.0 2.0 0.0; 0.0 1.0 1.0],)</code></pre><pre><code class="language-julia hljs">f(x) = [ x[1] * x[2], x[2] + x[3] ]

grad = jacobian(ReverseWithPrimal, f, [2.0, 3.0, 4.0], n_outs=Val((2,)))

# output
(derivs = ([3.0 2.0 0.0; 0.0 1.0 1.0],), val = [6.0, 7.0])</code></pre><p>This function will return an AbstractArray whose shape is <code>(size(output)..., size(input)...)</code>. No guarantees are presently made about the type of the AbstractArray returned by this function (which may or may not be the same as the input AbstractArray if provided).</p><p>In the future, when this function is extended to handle non-array return types,  this function will retun an AbstractArray of shape <code>size(output)</code> of values of the input type.  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/sugar.jl#L1172-L1225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.typetree"><a class="docstring-binding" href="#Enzyme.typetree"><code>Enzyme.typetree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function typetree(T, ctx, dl, seen=TypeTreeTable())</code></pre><p>Construct a Enzyme typetree from a Julia type.</p><div class="admonition is-warning" id="Warning-6c4f7e3225b76989"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6c4f7e3225b76989" title="Permalink"></a></header><div class="admonition-body"><p>When using a memoized lookup by providing <code>seen</code> across multiple calls to typtree the user must call <code>copy</code> on the returned value before mutating it.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/typetree.jl#L198-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.unsafe_to_pointer"><a class="docstring-binding" href="#Enzyme.unsafe_to_pointer"><code>Enzyme.unsafe_to_pointer</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unsafe_to_pointer</code></pre><div class="admonition is-warning" id="Warning-d66b319b7c800803"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d66b319b7c800803" title="Permalink"></a></header><div class="admonition-body"><p>Assumes that <code>val</code> is globally rooted and pointer to it can be leaked. Prefer <code>pointer_from_objref</code>. Only use inside Enzyme.jl should be for Types.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/utils.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><a class="docstring-binding" href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff(::ForwardMode, f, Activity, args::Annotation...)</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using forward mode.</p><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or similar argument. Unlike reverse mode in <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> arguments are not allowed here, since all derivative results of immutable objects will be returned and should instead use <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> or variants like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>.</p><p><code>Activity</code> is the Activity of the return value, it may be:</p><ul><li><code>Const</code> if the return is not to be differentiated with respect to</li><li><code>Duplicated</code>, if the return is being differentiated with respect to</li><li><code>BatchDuplicated</code>, like <code>Duplicated</code>, but computing multiple derivatives at once. All batch sizes must be the same for all arguments.</li></ul><p>Example returning both original return and derivative:</p><pre><code class="language-julia hljs">f(x) = x*x
res, ∂f_∂x = autodiff(ForwardWithPrimal, f, Duplicated, Duplicated(3.14, 1.0))

# output

(6.28, 9.8596)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">f(x) = x*x
∂f_∂x = autodiff(Forward, f, Duplicated, Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L565-L604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A0}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, RuntimeActivity, StrongZero, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}"><a class="docstring-binding" href="#EnzymeCore.autodiff-Union{Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A0}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, RuntimeActivity, StrongZero, RABI&lt;:EnzymeCore.ABI, Holomorphic, Nargs, ErrIfFuncWritten}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff(::ReverseMode, f, Activity, args::Annotation...)</code></pre><p>Auto-differentiate function <code>f</code> at arguments <code>args</code> using reverse mode.</p><p>Limitations:</p><ul><li><code>f</code> may only return a <code>Real</code> (of a built-in/primitive type) or <code>nothing</code>, not an array, struct, <code>BigFloat</code>, etc. To handle vector-valued return types, use a mutating <code>f!</code> that returns <code>nothing</code> and stores it&#39;s return value in one of the arguments, which must be wrapped in a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</li></ul><p><code>args</code> may be numbers, arrays, structs of numbers, structs of arrays and so on. Enzyme will only differentiate in respect to arguments that are wrapped in an <a href="#EnzymeCore.Active"><code>Active</code></a> (for arguments whose derivative result must be returned rather than mutated in place, such as primitive types and structs thereof) or <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> (for mutable arguments like arrays, <code>Ref</code>s and structs thereof).</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Active</code>.</p><p>Example:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(a, b, c, d) = a * √(b[1]^2 + b[2]^2) + c^2 * d^2
∂f_∂a, _, _, ∂f_∂d = autodiff(Reverse, f, Active, Active(a), Duplicated(b, ∂f_∂b), Const(c), Active(d))[1]

# output

(3.966106403010388, nothing, nothing, 54450.0)</code></pre><p>here, <code>autodiff</code> returns a tuple <span>$(\partial f/\partial a, \partial f/\partial d)$</span>, while <span>$\partial f/\partial b$</span> will be <em>added to</em> <code>∂f_∂b</code> (but not returned). <code>c</code> will be treated as <code>Const(c)</code>.</p><p>One can also request the original returned value of the computation.</p><p>Example:</p><pre><code class="language-julia hljs">Enzyme.autodiff(ReverseWithPrimal, x-&gt;x*x, Active(3.0))

# output

((6.0,), 9.0)</code></pre><div class="admonition is-info" id="Note-a49594340e3f42bb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a49594340e3f42bb" title="Permalink"></a></header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L297-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff-Union{Tuple{MMode}, Tuple{Nargs}, Tuple{A}, Tuple{Function, MMode, Type{A}, Vararg{Annotation, Nargs}}} where {A&lt;:Annotation, Nargs, MMode&lt;:Mode}"><a class="docstring-binding" href="#EnzymeCore.autodiff-Union{Tuple{MMode}, Tuple{Nargs}, Tuple{A}, Tuple{Function, MMode, Type{A}, Vararg{Annotation, Nargs}}} where {A&lt;:Annotation, Nargs, MMode&lt;:Mode}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff(::Function, ::Mode, args...)</code></pre><p>Specialization of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> to handle do argument closures.</p><pre><code class="language-julia hljs">
autodiff(Reverse, Active(3.1)) do x
  return x*x
end

# output
((6.2,),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L1025-L1039">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:Mode, Nargs}"><a class="docstring-binding" href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{FA}, Tuple{CMode, FA, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, CMode&lt;:Mode, Nargs}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, args...)</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but will try to guess the activity of the return value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L545-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:Mode, Nargs}"><a class="docstring-binding" href="#EnzymeCore.autodiff-Union{Tuple{Nargs}, Tuple{CMode}, Tuple{F}, Tuple{CMode, F, Vararg{Annotation, Nargs}}} where {F, CMode&lt;:Mode, Nargs}"><code>EnzymeCore.autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff(mode::Mode, f, ::Type{A}, args::Annotation...)</code></pre><p>Like <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but will try to extend f to an annotation, if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L524-L528">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, RABI&lt;:EnzymeCore.ABI, Holomorphic, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><a class="docstring-binding" href="#EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{RABI}, Tuple{Nargs}, Tuple{ReturnPrimal}, Tuple{A}, Tuple{FA}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, RABI, Holomorphic, ErrIfFuncWritten}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {FA&lt;:Annotation, A&lt;:Annotation, ReturnPrimal, Nargs, RABI&lt;:EnzymeCore.ABI, Holomorphic, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ReverseMode, f, Activity, args::Annotation...)</code></pre><p>Same as <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L676-L681">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, Nargs, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><a class="docstring-binding" href="#EnzymeCore.autodiff_deferred-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{RABI}, Tuple{Nargs}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, Nargs, RABI&lt;:EnzymeCore.ABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_deferred</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff_deferred(::ForwardMode, f, Activity, args::Annotation...)</code></pre><p>Same as <code>autodiff(::ForwardMode, f, Activity, args...)</code> but uses deferred compilation to support usage in GPU code, as well as high-order differentiation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L810-L815">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ShadowInit}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, ShadowInit}"><a class="docstring-binding" href="#EnzymeCore.autodiff_deferred_thunk-Union{Tuple{ShadowInit}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{TapeType}, Tuple{A2}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{TapeType}, Type{FA}, Type{A2}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A2&lt;:Annotation, TapeType, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, ShadowInit}"><code>EnzymeCore.autodiff_deferred_thunk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff_deferred_thunk(::ReverseModeSplit, TapeType::Type, ftype::Type{&lt;:Annotation}, Activity::Type{&lt;:Annotation}, argtypes::Type{&lt;:Annotation}...)</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

TapeType = tape_type(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})
forward, reverse = autodiff_deferred_thunk(ReverseSplitWithPrimal, TapeType, Const{typeof(f)}, Active{Float64}, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L1348-L1391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><a class="docstring-binding" href="#EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ForwardMode, ftype, Activity, argtypes::Type{&lt;:Annotation}...)</code></pre><p>Provide the thunk forward mode function for annotated function type ftype when called with args of type <code>argtypes</code>.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code> or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and<code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return the shadow (or nothing if not a <code>Duplicated</code> variant) and the primal (if requested).</p><p>Example returning both the return derivative and original return:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(ForwardWithPrimal, Const{typeof(f)}, Duplicated, Duplicated{Float64})
∂f_∂x, res = forward(Const(f), Duplicated(3.14, 1.0))

# output

(6.28, 9.8596)</code></pre><p>Example returning just the derivative:</p><pre><code class="language-julia hljs">a = 4.2
b = [2.2, 3.3]; ∂f_∂b = zero(b)
c = 55; d = 9

f(x) = x*x
forward = autodiff_thunk(Forward, Const{typeof(f)}, Duplicated, Duplicated{Float64})
∂f_∂x, = forward(Const(f), Duplicated(3.14, 1.0))

# output

(6.28,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L1056-L1099">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{FA}, Type{A0}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, ShadowInit, RuntimeActivity, StrongZero}"><a class="docstring-binding" href="#EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ModifiedBetweenT}, Tuple{Width}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{A0}, Tuple{FA}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetweenT, RABI, false, ErrIfFuncWritten, ShadowInit}, Type{FA}, Type{A0}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {FA&lt;:Annotation, A0&lt;:Annotation, ReturnPrimal, ReturnShadow, Width, ModifiedBetweenT, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, ShadowInit, RuntimeActivity, StrongZero}"><code>EnzymeCore.autodiff_thunk</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autodiff_thunk(::ReverseModeSplit, ftype, Activity, argtypes::Type{&lt;:Annotation}...)</code></pre><p>Provide the split forward and reverse pass functions for annotated function type ftype when called with args of type <code>argtypes</code> when using reverse mode.</p><p><code>Activity</code> is the Activity of the return value, it may be <code>Const</code>, <code>Active</code>, or <code>Duplicated</code> (or its variants <code>DuplicatedNoNeed</code>, <code>BatchDuplicated</code>, and <code>BatchDuplicatedNoNeed</code>).</p><p>The forward function will return a tape, the primal (or nothing if not requested), and the shadow (or nothing if not a <code>Duplicated</code> variant), and tapes the corresponding type arguements provided.</p><p>The reverse function will return the derivative of <code>Active</code> arguments, updating the <code>Duplicated</code> arguments in place. The same arguments to the forward pass should be provided, followed by the adjoint of the return (if the return is active), and finally the tape from the forward pass.</p><p>Example:</p><pre><code class="language-julia hljs">
A = [2.2]; ∂A = zero(A)
v = 3.3

function f(A, v)
    res = A[1] * v
    A[1] = 0
    res
end

forward, reverse = autodiff_thunk(ReverseSplitWithPrimal, Const{typeof(f)}, Active, Duplicated{typeof(A)}, Active{typeof(v)})

tape, result, shadow_result  = forward(Const(f), Duplicated(A, ∂A), Active(v))
_, ∂v = reverse(Const(f), Duplicated(A, ∂A), Active(v), 1.0, tape)[1]

result, ∂v, ∂A

# output

(7.26, 2.2, [3.3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/Enzyme.jl#L904-L946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ABI"><a class="docstring-binding" href="#EnzymeCore.ABI"><code>EnzymeCore.ABI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type ABI</code></pre><p>Abstract type for what ABI  will be used.</p><p><strong>Subtypes</strong></p><ul><li><a href="#EnzymeCore.FFIABI"><code>FFIABI</code></a> (the default)</li><li><a href="#EnzymeCore.InlineABI"><code>InlineABI</code></a></li><li><a href="#EnzymeCore.NonGenABI"><code>NonGenABI</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L209-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Active"><a class="docstring-binding" href="#EnzymeCore.Active"><code>EnzymeCore.Active</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Active(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as active, Enzyme will auto-differentiate in respect <code>Active</code> arguments.</p><div class="admonition is-info" id="Note-a49594340e3f42bb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a49594340e3f42bb" title="Permalink"></a></header><div class="admonition-body"><p>Enzyme gradients with respect to integer values are zero. <a href="#EnzymeCore.Active"><code>Active</code></a> will automatically convert plain integers to floating point values, but cannot do so for integer values in tuples and structs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L36-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Annotation"><a class="docstring-binding" href="#EnzymeCore.Annotation"><code>EnzymeCore.Annotation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Annotation{T}</code></pre><p>Abstract type for <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> function argument wrappers like <a href="#EnzymeCore.Const"><code>Const</code></a>, <a href="#EnzymeCore.Active"><code>Active</code></a> and <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L14-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.BatchDuplicated"><a class="docstring-binding" href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BatchDuplicated(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L126-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.BatchDuplicatedNoNeed"><a class="docstring-binding" href="#EnzymeCore.BatchDuplicatedNoNeed"><code>EnzymeCore.BatchDuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BatchDuplicatedNoNeed(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.DuplicatedNoNeed"><code>DuplicatedNoNeed</code></a>, except contains several shadows to compute derivatives for all at once. Argument <code>∂f_∂xs</code> should be a tuple of the several values of type <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L154-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.BatchMixedDuplicated"><a class="docstring-binding" href="#EnzymeCore.BatchMixedDuplicated"><code>EnzymeCore.BatchMixedDuplicated</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BatchMixedDuplicated(x, ∂f_∂xs)</code></pre><p>Like <a href="#EnzymeCore.MixedDuplicated"><code>MixedDuplicated</code></a>, except contains several shadows to compute derivatives for all at once. Only used within custom rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L195-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Const"><a class="docstring-binding" href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Const(x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as constant, Enzyme will not auto-differentiate in respect <code>Const</code> arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Duplicated"><a class="docstring-binding" href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Duplicated(x, ∂f_∂x)</code></pre><p>Mark a function argument <code>x</code> of <a href="#EnzymeCore.autodiff-Union{Tuple{A}, Tuple{FA}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, FA, Type{A}, Vararg{Annotation, Nargs}}} where {ReturnPrimal, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero, FA&lt;:Annotation, A&lt;:Annotation}"><code>autodiff</code></a> as duplicated, Enzyme will auto-differentiate in respect to such arguments, with <code>dx</code> acting as an accumulator for gradients (so <span>$\partial f / \partial x$</span> will be <em>added to</em>) <code>∂f_∂x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L57-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.DuplicatedNoNeed"><a class="docstring-binding" href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DuplicatedNoNeed(x, ∂f_∂x)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except also specifies that Enzyme may avoid computing the original result and only compute the derivative values. This creates opportunities for improved performance.</p><pre><code class="language-julia hljs">
function square_byref(out, v)
    out[] = v * v
    nothing
end

out = Ref(0.0)
dout = Ref(1.0)
Enzyme.autodiff(Reverse, square_byref, DuplicatedNoNeed(out, dout), Active(1.0))
dout[]

# output
0.0</code></pre><p>For example, marking the out variable as <code>DuplicatedNoNeed</code> instead of <code>Duplicated</code> allows Enzyme to avoid computing <code>v * v</code> (while still computing its derivative).</p><p>This should only be used if <code>x</code> is a write-only variable. Otherwise, if the differentiated function stores values in <code>x</code> and reads them back in subsequent computations, using <code>DuplicatedNoNeed</code> may result in incorrect derivatives. In particular, <code>DuplicatedNoNeed</code> should not be used for preallocated workspace, even if the user might not care about its final value, as marking a variable as NoNeed means that reads from the variable are now undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L79-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.FFIABI"><a class="docstring-binding" href="#EnzymeCore.FFIABI"><code>EnzymeCore.FFIABI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct FFIABI &lt;: ABI</code></pre><p>Foreign function call <a href="#EnzymeCore.ABI"><code>ABI</code></a>. JIT the differentiated function, then inttoptr call the address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L222-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ForwardMode"><a class="docstring-binding" href="#EnzymeCore.ForwardMode"><code>EnzymeCore.ForwardMode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ForwardMode{
    ReturnPrimal,
    ABI,
    ErrIfFuncWritten,
    RuntimeActivity,
    StrongZero
} &lt;: Mode{ABI,ErrIfFuncWritten,RuntimeActivity,StrongZero}</code></pre><p>Subtype of <a href="#EnzymeCore.Mode"><code>Mode</code></a> for forward mode differentiation.</p><p><strong>Type parameters</strong></p><ul><li><code>ReturnPrimal</code>: whether to return the primal return value from the augmented-forward.</li><li>other parameters: see <a href="#EnzymeCore.Mode"><code>Mode</code></a></li></ul><div class="admonition is-warning" id="Warning-ebe28be896617120"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ebe28be896617120" title="Permalink"></a></header><div class="admonition-body"><p>The type parameters of <code>ForwardMode</code> are not part of the public API and can change without notice. Please use one of the following concrete instantiations instead:</p><ul><li><a href="#EnzymeCore.Forward"><code>Forward</code></a></li><li><a href="#EnzymeCore.ForwardWithPrimal"><code>ForwardWithPrimal</code></a></li></ul><p>You can modify them with the following helper functions:</p><ul><li><a href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>WithPrimal</code></a> / <a href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>NoPrimal</code></a></li><li><a href="#EnzymeCore.set_err_if_func_written"><code>set_err_if_func_written</code></a> / <a href="#EnzymeCore.clear_err_if_func_written"><code>clear_err_if_func_written</code></a></li><li><a href="#EnzymeCore.set_runtime_activity"><code>set_runtime_activity</code></a> / <a href="#EnzymeCore.clear_runtime_activity"><code>clear_runtime_activity</code></a></li><li><a href="#EnzymeCore.set_abi"><code>set_abi</code></a></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L482-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.InlineABI"><a class="docstring-binding" href="#EnzymeCore.InlineABI"><code>EnzymeCore.InlineABI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct InlineABI &lt;: ABI</code></pre><p>Inlining function call <a href="#EnzymeCore.ABI"><code>ABI</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L229-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.MixedDuplicated"><a class="docstring-binding" href="#EnzymeCore.MixedDuplicated"><code>EnzymeCore.MixedDuplicated</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MixedDuplicated(x, ∂f_∂x)</code></pre><p>Like <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a>, except x may contain both active [immutable] and duplicated [mutable] data which is differentiable. Only used within custom rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L183-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Mode"><a class="docstring-binding" href="#EnzymeCore.Mode"><code>EnzymeCore.Mode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type Mode{ABI,ErrIfFuncWritten,RuntimeActivity,StrongZero}</code></pre><p>Abstract type for which differentiation mode will be used.</p><p><strong>Subtypes</strong></p><ul><li><a href="#EnzymeCore.ForwardMode"><code>ForwardMode</code></a></li><li><a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a></li><li><a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a></li></ul><p><strong>Type parameters</strong></p><ul><li><code>ABI</code>: what runtime <a href="#EnzymeCore.ABI"><code>ABI</code></a> to use</li><li><code>ErrIfFuncWritten</code>: whether to error when the function differentiated is a closure and written to.</li><li><code>RuntimeActivity</code>: whether to enable runtime activity (default off). Runtime Activity is required is the differentiability of all mutable variables cannot be determined statically. For a deeper explanation see the <a href="../faq/#faq-runtime-activity">FAQ</a></li><li><code>StrongZero</code>: whether to enforce that propagating a zero derivative input always ends up in zero derivative outputs. This is required to avoid nan&#39;s if one of the arguments may be infinite or nan. For a deeper explanation see the <a href="../faq/#faq-strong-zero">FAQ</a></li></ul><div class="admonition is-warning" id="Warning-97c4ce65cf5fd856"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-97c4ce65cf5fd856" title="Permalink"></a></header><div class="admonition-body"><p>The type parameters of <code>Mode</code> are not part of the public API and can change without notice. You can modify them with the following helper functions:</p><ul><li><a href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>WithPrimal</code></a> / <a href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>NoPrimal</code></a></li><li><a href="#EnzymeCore.set_err_if_func_written"><code>set_err_if_func_written</code></a> / <a href="#EnzymeCore.clear_err_if_func_written"><code>clear_err_if_func_written</code></a></li><li><a href="#EnzymeCore.set_runtime_activity"><code>set_runtime_activity</code></a> / <a href="#EnzymeCore.clear_runtime_activity"><code>clear_runtime_activity</code></a></li><li><a href="#EnzymeCore.set_strong_zero"><code>set_strong_zero</code></a> / <a href="#EnzymeCore.clear_strong_zero"><code>clear_strong_zero</code></a></li><li><a href="#EnzymeCore.set_abi"><code>set_abi</code></a></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L245-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.NonGenABI"><a class="docstring-binding" href="#EnzymeCore.NonGenABI"><code>EnzymeCore.NonGenABI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct NonGenABI &lt;: ABI</code></pre><p>Non-generated function <a href="#EnzymeCore.ABI"><code>ABI</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L236-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseMode"><a class="docstring-binding" href="#EnzymeCore.ReverseMode"><code>EnzymeCore.ReverseMode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReverseMode{
    ReturnPrimal,
    RuntimeActivity,
    StrongZero,
    ABI,
    Holomorphic,
    ErrIfFuncWritten
} &lt;: Mode{ABI,ErrIfFuncWritten,RuntimeActivity,StrongZero}</code></pre><p>Subtype of <a href="#EnzymeCore.Mode"><code>Mode</code></a> for reverse mode differentiation.</p><p><strong>Type parameters</strong></p><ul><li><code>ReturnPrimal</code>: whether to return the primal return value from the augmented-forward pass.</li><li><code>Holomorphic</code>: Whether the complex result function is holomorphic and we should compute <code>d/dz</code></li><li>other parameters: see <a href="#EnzymeCore.Mode"><code>Mode</code></a></li></ul><div class="admonition is-warning" id="Warning-8914cfd2bd2ac6ef"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-8914cfd2bd2ac6ef" title="Permalink"></a></header><div class="admonition-body"><p>The type parameters of <code>ReverseMode</code> are not part of the public API and can change without notice. Please use one of the following concrete instantiations instead:</p><ul><li><a href="#EnzymeCore.Reverse"><code>Reverse</code></a></li><li><a href="#EnzymeCore.ReverseWithPrimal"><code>ReverseWithPrimal</code></a></li><li><a href="#EnzymeCore.ReverseHolomorphic"><code>ReverseHolomorphic</code></a></li><li><a href="#EnzymeCore.ReverseHolomorphicWithPrimal"><code>ReverseHolomorphicWithPrimal</code></a></li></ul><p>You can modify them with the following helper functions:</p><ul><li><a href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>WithPrimal</code></a> / <a href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>NoPrimal</code></a></li><li><a href="#EnzymeCore.set_err_if_func_written"><code>set_err_if_func_written</code></a> / <a href="#EnzymeCore.clear_err_if_func_written"><code>clear_err_if_func_written</code></a></li><li><a href="#EnzymeCore.set_runtime_activity"><code>set_runtime_activity</code></a> / <a href="#EnzymeCore.clear_runtime_activity"><code>clear_runtime_activity</code></a></li><li><a href="#EnzymeCore.set_strong_zero"><code>set_strong_zero</code></a> / <a href="#EnzymeCore.clear_strong_zero"><code>clear_strong_zero</code></a></li><li><a href="#EnzymeCore.set_abi"><code>set_abi</code></a></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L292-L323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseModeSplit"><a class="docstring-binding" href="#EnzymeCore.ReverseModeSplit"><code>EnzymeCore.ReverseModeSplit</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ReverseModeSplit{
    ReturnPrimal,
    ReturnShadow,
    Width,
    RuntimeActivity,
    StrongZero,
    ModifiedBetween,
    ABI,
    ErrFuncIfWritten
} &lt;: Mode{ABI,ErrIfFuncWritten,RuntimeActivity,StrongZero}
    WithPrimal(::Enzyme.Mode)</code></pre><p>Subtype of <a href="#EnzymeCore.Mode"><code>Mode</code></a> for split reverse mode differentiation, to use in <a href="#EnzymeCore.autodiff_thunk-Union{Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ErrIfFuncWritten}, Tuple{Nargs}, Tuple{RABI}, Tuple{A}, Tuple{FA}, Tuple{ReturnPrimal}, Tuple{ForwardMode{ReturnPrimal, RABI, ErrIfFuncWritten, RuntimeActivity, StrongZero}, Type{FA}, Type{A}, Vararg{Type{&lt;:Annotation}, Nargs}}} where {ReturnPrimal, FA&lt;:Annotation, A&lt;:Annotation, RABI&lt;:EnzymeCore.ABI, Nargs, ErrIfFuncWritten, RuntimeActivity, StrongZero}"><code>autodiff_thunk</code></a> and variants.</p><p><strong>Type parameters</strong></p><ul><li><code>ReturnShadow</code>: whether to return the shadow return value from the augmented-forward.</li><li><code>Width</code>: batch size (pick <code>0</code> to derive it automatically)</li><li><code>ModifiedBetween</code>: <code>Tuple</code> of each argument&#39;s &quot;modified between&quot; state (pick <code>true</code> to derive it automatically).</li><li>other parameters: see <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a></li></ul><div class="admonition is-warning" id="Warning-df958ec2ac891346"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-df958ec2ac891346" title="Permalink"></a></header><div class="admonition-body"><p>The type parameters of <code>ReverseModeSplit</code> are not part of the public API and can change without notice. Please use one of the following concrete instantiations instead: </p><ul><li><a href="#EnzymeCore.ReverseSplitNoPrimal"><code>ReverseSplitNoPrimal</code></a></li><li><a href="#EnzymeCore.ReverseSplitWithPrimal"><code>ReverseSplitWithPrimal</code></a></li></ul><p>You can modify them with the following helper functions:</p><ul><li><a href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>WithPrimal</code></a> / <a href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>NoPrimal</code></a></li><li><a href="#EnzymeCore.set_err_if_func_written"><code>set_err_if_func_written</code></a> / <a href="#EnzymeCore.clear_err_if_func_written"><code>clear_err_if_func_written</code></a></li><li><a href="#EnzymeCore.set_runtime_activity"><code>set_runtime_activity</code></a> / <a href="#EnzymeCore.clear_runtime_activity"><code>clear_runtime_activity</code></a></li><li><a href="#EnzymeCore.set_strong_zero"><code>set_strong_zero</code></a> / <a href="#EnzymeCore.clear_strong_zero"><code>clear_strong_zero</code></a></li><li><a href="#EnzymeCore.set_abi"><code>set_abi</code></a></li><li><a href="#EnzymeCore.ReverseSplitModified-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{MBO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{MB}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>ReverseSplitModified</code></a>, <a href="#EnzymeCore.ReverseSplitWidth-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{WidthO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, WidthO, MB, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{Width}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, WidthO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>ReverseSplitWidth</code></a></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L394-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Forward"><a class="docstring-binding" href="#EnzymeCore.Forward"><code>EnzymeCore.Forward</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Forward</code></pre><p>Default instance of <a href="#EnzymeCore.ForwardMode"><code>ForwardMode</code></a> that doesn&#39;t return the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L512-L516">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ForwardWithPrimal"><a class="docstring-binding" href="#EnzymeCore.ForwardWithPrimal"><code>EnzymeCore.ForwardWithPrimal</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ForwardWithPrimal</code></pre><p>Default instance of <a href="#EnzymeCore.ForwardMode"><code>ForwardMode</code></a> that also returns the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L519-L523">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Reverse"><a class="docstring-binding" href="#EnzymeCore.Reverse"><code>EnzymeCore.Reverse</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const Reverse</code></pre><p>Default instance of <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> that doesn&#39;t return the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L326-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseHolomorphic"><a class="docstring-binding" href="#EnzymeCore.ReverseHolomorphic"><code>EnzymeCore.ReverseHolomorphic</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ReverseHolomorphic</code></pre><p>Holomorphic instance of <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> that doesn&#39;t return the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseHolomorphicWithPrimal"><a class="docstring-binding" href="#EnzymeCore.ReverseHolomorphicWithPrimal"><code>EnzymeCore.ReverseHolomorphicWithPrimal</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ReverseHolomorphicWithPrimal</code></pre><p>Holomorphic instance of <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> that also returns the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L347-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseSplitNoPrimal"><a class="docstring-binding" href="#EnzymeCore.ReverseSplitNoPrimal"><code>EnzymeCore.ReverseSplitNoPrimal</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ReverseSplitNoPrimal</code></pre><p>Default instance of <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> that doesn&#39;t return the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L431-L435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseSplitWithPrimal"><a class="docstring-binding" href="#EnzymeCore.ReverseSplitWithPrimal"><code>EnzymeCore.ReverseSplitWithPrimal</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ReverseSplitWithPrimal</code></pre><p>Default instance of <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> that also returns the primal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L438-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseWithPrimal"><a class="docstring-binding" href="#EnzymeCore.ReverseWithPrimal"><code>EnzymeCore.ReverseWithPrimal</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const ReverseWithPrimal</code></pre><p>Default instance of <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> that also returns the primal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L333-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Combined-Union{Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><a class="docstring-binding" href="#EnzymeCore.Combined-Union{Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.Combined</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Combined(::ReverseMode)</code></pre><p>Turn a <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> object into a <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> object while preserving as many of the settings as possible.</p><p>This function acts as the identity on a <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a>.</p><p>See also <a href="#EnzymeCore.Split-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}, Val{ShadowInit}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>Split</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L753-L761">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><a class="docstring-binding" href="#EnzymeCore.NoPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.NoPrimal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NoPrimal(::Mode)</code></pre><p>Return a new mode which excludes the primal value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L378-L382">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseSplitModified-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{MBO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{MB}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><a class="docstring-binding" href="#EnzymeCore.ReverseSplitModified-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{MBO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{MB}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, MBO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.ReverseSplitModified</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ReverseSplitModified(::ReverseModeSplit, ::Val{MB})</code></pre><p>Return a new instance of <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> mode where <code>ModifiedBetween</code> is set to <code>MB</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L445-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ReverseSplitWidth-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{WidthO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, WidthO, MB, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{Width}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, WidthO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><a class="docstring-binding" href="#EnzymeCore.ReverseSplitWidth-Union{Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{WidthO}, Tuple{MB}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, WidthO, MB, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}, Val{Width}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, MB, WidthO, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.ReverseSplitWidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ReverseSplitWidth(::ReverseModeSplit, ::Val{W})</code></pre><p>Return a new instance of <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> mode where <code>Width</code> is set to <code>W</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L452-L456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.Split-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}, Val{ShadowInit}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><a class="docstring-binding" href="#EnzymeCore.Split-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}}, Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}, Val{ReturnShadow}, Val{Width}, Val{ModifiedBetween}, Val{ShadowInit}}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>EnzymeCore.Split</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Split(
    ::ReverseMode, [::Val{ReturnShadow}, ::Val{Width}, ::Val{ModifiedBetween}, ::Val{ShadowInit}]
)</code></pre><p>Turn a <a href="#EnzymeCore.ReverseMode"><code>ReverseMode</code></a> object into a <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a> object while preserving as many of the settings as possible. The rest of the settings can be configured with optional positional arguments of <code>Val</code> type.</p><p>This function acts as the identity on a <a href="#EnzymeCore.ReverseModeSplit"><code>ReverseModeSplit</code></a>.</p><p>See also <a href="#EnzymeCore.Combined-Union{Tuple{ReverseModeSplit{ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}}, Tuple{ShadowInit}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{ModifiedBetween}, Tuple{Width}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnShadow}, Tuple{ReturnPrimal}} where {ReturnPrimal, ReturnShadow, RuntimeActivity, StrongZero, Width, ModifiedBetween, ABI, Holomorphic, ErrIfFuncWritten, ShadowInit}"><code>Combined</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L699-L710">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><a class="docstring-binding" href="#EnzymeCore.WithPrimal-Union{Tuple{ReverseMode{ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}}, Tuple{ErrIfFuncWritten}, Tuple{Holomorphic}, Tuple{ABI}, Tuple{StrongZero}, Tuple{RuntimeActivity}, Tuple{ReturnPrimal}} where {ReturnPrimal, RuntimeActivity, StrongZero, ABI, Holomorphic, ErrIfFuncWritten}"><code>EnzymeCore.WithPrimal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">WithPrimal(::Mode)</code></pre><p>Return a new mode which includes the primal value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L371-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.clear_err_if_func_written"><a class="docstring-binding" href="#EnzymeCore.clear_err_if_func_written"><code>EnzymeCore.clear_err_if_func_written</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_err_if_func_written(::Mode)</code></pre><p>Return a new mode which doesn&#39;t throw an error for attempts to write into an unannotated function object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L651-L655">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.clear_runtime_activity"><a class="docstring-binding" href="#EnzymeCore.clear_runtime_activity"><code>EnzymeCore.clear_runtime_activity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_runtime_activity(::Mode)</code></pre><p>Return a new mode where runtime activity analysis is deactivated. See <a href="#EnzymeCore.Mode">Enzyme.Mode</a> for more information on runtime activity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L668-L672">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.clear_strong_zero"><a class="docstring-binding" href="#EnzymeCore.clear_strong_zero"><code>EnzymeCore.clear_strong_zero</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_strong_zero(::Mode)</code></pre><p>Return a new mode where strong_zero is deactivated. See <a href="#EnzymeCore.Mode">Enzyme.Mode</a> for more information on strong zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L685-L689">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.compiler_job_from_backend"><a class="docstring-binding" href="#EnzymeCore.compiler_job_from_backend"><code>EnzymeCore.compiler_job_from_backend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compiler_job_from_backend(::KernelAbstractions.Backend, F::Type, TT:Type)::GPUCompiler.CompilerJob</code></pre><p>Returns a GPUCompiler CompilerJob from a backend as specified by the first argument to the function.</p><p>For example, in CUDA one would do:</p><pre><code class="language-julia hljs">function EnzymeCore.compiler_job_from_backend(::CUDABackend, @nospecialize(F::Type), @nospecialize(TT::Type))
    mi = GPUCompiler.methodinstance(F, TT)
    return GPUCompiler.CompilerJob(mi, CUDA.compiler_config(CUDA.device()))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L592-L605">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.ignore_derivatives-Tuple{T} where T"><a class="docstring-binding" href="#EnzymeCore.ignore_derivatives-Tuple{T} where T"><code>EnzymeCore.ignore_derivatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ignore_derivatives(x::T)::T</code></pre><p>Behaves like the <code>identity</code> function, but disconnects the &quot;shadow&quot; associated with <code>x</code>. This has the effect of preventing any derivatives from being propagated through <code>x</code>.</p><div class="admonition is-compat" id="Enzyme-0.13.74-62c899e64483517e"><header class="admonition-header">Enzyme 0.13.74<a class="admonition-anchor" href="#Enzyme-0.13.74-62c899e64483517e" title="Permalink"></a></header><div class="admonition-body"><p>Support for <code>ignore_derivatives</code> was added in Enzyme 0.13.74.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L623-L632">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.make_zero"><a class="docstring-binding" href="#EnzymeCore.make_zero"><code>EnzymeCore.make_zero</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_zero(::Type{T}, seen::IdDict, prev::T, ::Val{copy_if_inactive}=Val(false))::T</code></pre><p>Recursively make a zero&#39;d copy of the value <code>prev</code> of type <code>T</code>. The argument <code>copy_if_inactive</code> specifies what to do if the type <code>T</code> is guaranteed to be inactive, use the primal (the default) or still copy the value. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L553-L558">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.make_zero!"><a class="docstring-binding" href="#EnzymeCore.make_zero!"><code>EnzymeCore.make_zero!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_zero!(val::T, seen::IdSet{Any}=IdSet())::Nothing</code></pre><p>Recursively set a variables differentiable fields to zero.</p><div class="admonition is-category-warn" id="Warn-22f3166fa8993dd8"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-22f3166fa8993dd8" title="Permalink"></a></header><div class="admonition-body"><p>Only applicable for mutable types <code>T</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L561-L568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}"><a class="docstring-binding" href="#EnzymeCore.make_zero-Union{Tuple{copy_if_inactive}, Tuple{T}, Tuple{T, Val{copy_if_inactive}}} where {T, copy_if_inactive}"><code>EnzymeCore.make_zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_zero(prev::T)</code></pre><p>Helper function to recursively make zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L581-L585">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><a class="docstring-binding" href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>EnzymeCore.needs_primal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">needs_primal(::Mode)
needs_primal(::Type{Mode})</code></pre><p>Returns <code>true</code> if the mode needs the primal value, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L385-L390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.remake_zero!"><a class="docstring-binding" href="#EnzymeCore.remake_zero!"><code>EnzymeCore.remake_zero!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">remake_zero!(val::T, seen::IdSet{Any}=IdSet())::Nothing</code></pre><p>Recursively set a variables differentiable fields to zero.</p><div class="admonition is-category-warn" id="Warn-1f390e357a3463d9"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-1f390e357a3463d9" title="Permalink"></a></header><div class="admonition-body"><p>This assumes that the input value was previously generated by make_zero. Otherwise, this may not zero the immutable fields of a struct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L571-L578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.runtime_activity-Union{Tuple{Mode{&lt;:Any, &lt;:Any, RuntimeActivity}}, Tuple{RuntimeActivity}} where RuntimeActivity"><a class="docstring-binding" href="#EnzymeCore.runtime_activity-Union{Tuple{Mode{&lt;:Any, &lt;:Any, RuntimeActivity}}, Tuple{RuntimeActivity}} where RuntimeActivity"><code>EnzymeCore.runtime_activity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">runtime_activity(::Mode)
strong_zero(::Type{&lt;:Mode})</code></pre><p>Returns whether the given mode has runtime activity set. For a deeper explanation of what strong zero is see the <a href="../faq/#faq-runtime-activity">FAQ</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L274-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.set_abi"><a class="docstring-binding" href="#EnzymeCore.set_abi"><code>EnzymeCore.set_abi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_abi(::Mode, ::Type{ABI})</code></pre><p>Return a new mode with its <a href="#EnzymeCore.ABI"><code>ABI</code></a> set to the chosen type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L692-L696">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.set_err_if_func_written"><a class="docstring-binding" href="#EnzymeCore.set_err_if_func_written"><code>EnzymeCore.set_err_if_func_written</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_err_if_func_written(::Mode)</code></pre><p>Return a new mode which throws an error for any attempt to write into an unannotated function object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L644-L648">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.set_runtime_activity"><a class="docstring-binding" href="#EnzymeCore.set_runtime_activity"><code>EnzymeCore.set_runtime_activity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_runtime_activity(::Mode)
set_runtime_activity(::Mode, activity::Bool)
set_runtime_activity(::Mode, config::Union{FwdConfig,RevConfig})
set_runtime_activity(::Mode, prev::Mode)</code></pre><p>Return a new mode where runtime activity analysis is activated / set to the desired value. See the <a href="../faq/#faq-runtime-activity">FAQ</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L658-L665">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.set_strong_zero"><a class="docstring-binding" href="#EnzymeCore.set_strong_zero"><code>EnzymeCore.set_strong_zero</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_strong_zero(::Mode)
set_strong_zero(::Mode, activity::Bool)
set_strong_zero(::Mode, config::Union{FwdConfig,RevConfig})
set_strong_zero(::Mode, prev::Mode)</code></pre><p>Return a new mode where strong zero is activated / set to the desired value. See the <a href="../faq/#faq-strong-zero">FAQ</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L675-L682">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.strong_zero-Union{Tuple{Mode{&lt;:Any, &lt;:Any, &lt;:Any, StrongZero}}, Tuple{StrongZero}} where StrongZero"><a class="docstring-binding" href="#EnzymeCore.strong_zero-Union{Tuple{Mode{&lt;:Any, &lt;:Any, &lt;:Any, StrongZero}}, Tuple{StrongZero}} where StrongZero"><code>EnzymeCore.strong_zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">strong_zero(::Mode)
strong_zero(::Type{&lt;:Mode})</code></pre><p>Returns whether the given mode has strong zero set. For a deeper explanation of what strong zero is see the <a href="../faq/#faq-strong-zero">FAQ</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L283-L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.within_autodiff-Tuple{}"><a class="docstring-binding" href="#EnzymeCore.within_autodiff-Tuple{}"><code>EnzymeCore.within_autodiff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">within_autodiff()</code></pre><p>Returns true if within autodiff, otherwise false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/EnzymeCore.jl#L614-L618">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.AugmentedReturn"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>EnzymeCore.EnzymeRules.AugmentedReturn</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AugmentedReturn(primal, shadow, tape)</code></pre><p>Augment the primal return value of a function with its shadow, as well as any additional information needed to correctly compute the reverse pass, stored in <code>tape</code>.</p><p>Unless specified by the config that a variable is not overwritten, rules must assume any arrays/data structures/etc are overwritten between the forward and the reverse pass. Any floats or variables passed by value are always preserved as is (as are the arrays themselves, just not necessarily the values in the array).</p><p>See also <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L203-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.FwdConfig"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.FwdConfig"><code>EnzymeCore.EnzymeRules.FwdConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FwdConfig{NeedsPrimal, NeedsShadow, Width, RuntimeActivity, StrongZero}
FwdConfigWidth{Width} = FwdConfig{&lt;:Any, &lt;:Any, Width}</code></pre><p>Configuration type to dispatch on in custom forward rules (see <a href="#EnzymeCore.EnzymeRules.forward"><code>forward</code></a>.</p><ul><li><code>NeedsPrimal</code> and <code>NeedsShadow</code>: boolean values specifying whether the primal and shadow (resp.) should be returned.</li><li><code>Width</code>: an integer that specifies the number of adjoints/shadows simultaneously being propagated.</li><li><code>RuntimeActivity</code>: whether runtime activity is enabled. See the <a href="../faq/#faq-runtime-activity">FAQ</a> for more information.</li><li><code>StrongZero</code>: whether strong zero is enabled. See the <a href="../faq/#faq-strong-zero">FAQ</a> for more information.</li></ul><p>Getters for the type parameters are provided by <a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>needs_primal</code></a>, <a href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>needs_shadow</code></a>, <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a>, <code>runtime_activity</code>, and <code>strong_zero</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L33-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.RevConfig"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.RevConfig"><code>EnzymeCore.EnzymeRules.RevConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RevConfig{NeedsPrimal, NeedsShadow, Width, Overwritten, RuntimeActivity, StrongZero}
RevConfigWidth{Width} = RevConfig{&lt;:Any, &lt;:Any, Width}</code></pre><p>Configuration type to dispatch on in custom reverse rules (see <a href="#EnzymeCore.EnzymeRules.augmented_primal"><code>augmented_primal</code></a> and <a href="#EnzymeCore.EnzymeRules.reverse"><code>reverse</code></a>).</p><ul><li><code>NeedsPrimal</code> and <code>NeedsShadow</code>: boolean values specifying whether the primal and shadow (resp.) should be returned.</li><li><code>Width</code>: an integer that specifies the number of adjoints/shadows simultaneously being propagated.</li><li><code>Overwritten</code>: a tuple of booleans of whether each argument (including the function itself) is modified between the  forward and reverse pass (<code>true</code> if potentially modified between).</li><li><code>RuntimeActivity</code>: whether runtime activity is enabled. See the <a href="../faq/#faq-runtime-activity">FAQ</a> for more information.</li><li><code>StrongZero</code>: whether strong zero is enabled. See the <a href="../faq/#faq-strong-zero">FAQ</a> for more information.</li></ul><p>Getters for the type parameters are provided by <a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>needs_primal</code></a>, <a href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>needs_shadow</code></a>, <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a>, <a href="#EnzymeCore.EnzymeRules.overwritten-Union{Tuple{EnzymeCore.EnzymeRules.RevConfigWidth{&lt;:Any, var&quot;#s7&quot;, var&quot;#s3&quot;, Overwritten} where {var&quot;#s7&quot;, var&quot;#s3&quot;}}, Tuple{Overwritten}} where Overwritten"><code>overwritten</code></a>, <code>runtime_activity</code>, and <code>strong_zero</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L87-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.@easy_rule-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.@easy_rule-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeCore.EnzymeRules.@easy_rule</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@easy_rule(f(x₁::T1, x₂::T2, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple forward and reverse Enzyme rules using the provided partial derivatives.</p><p>The <code>easy_rule</code> macro assumes that the function <code>f</code> does not mutate any of its arguments, does not read from global data, and no output aliases with any other output nor input.</p><p>The <code>easy_rule</code> macro only works if inputs are scalars or arrays of scalars, and the result is a scalar, array, or tuple thereof.</p><p>For each output result (a single output is assumed if a scalar is returned), a tuple of partial derivatives is expected. Specifically, each tuple contains one entry for each argument to <code>f</code>. This entry should contain the jacobian <code>∂fi_∂xj</code> where <code>i</code> is the number of the output, and <code>j</code> is the number of the input. If both input <code>i</code> and output <code>j</code> are scalars, <code>∂fi_∂xj</code> should be a scalar. If at least one of these are an abstractarray, <code>∂fi_∂xj</code> should be a tensor of size <code>(size(output[j])..., size(input[i])...)</code>, where scalars are considered zero-dimensional.</p><p>The arguments to <code>f</code> can either have no type constraints, or specific type constraints.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>At present this does not support defining for closures/functors.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-julia hljs">@easy_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-julia hljs">@easy_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>If a specific argument has no partial derivative, then all corresponding argument values can instead be marked <code>@Constant</code>. For example, consider the case where <code>config</code> has no derivative.</p><pre><code class="language-julia hljs">@easy_rule(f(config, x, ...),
             @setup(nothing),
             (@Constant, ∂f₁_∂x, ...),
             (@Constant, ∂f₂_∂x, ...),
             ...)</code></pre><p><strong>Examples</strong></p><p>Let&#39;s write an <code>@easy_rule</code> for a simple trigonometric function. Enzyme already has rules for <code>sin</code> and <code>cos</code>, but for the sake of illustration we can define a new pass-through function to oen of them to demostrate the <code>@easy_rule</code> interface.</p><pre><code class="language-julia hljs">mycos(x) = cos(x)

# forward-mode rule for the new function
EnzymeRules.@easy_rule(
    mycos(x::AbstractFloat),
    @setup(),
    (-sin(x),)
)</code></pre><p>Then this rule can be tested by running <code>Enzyme.autodiff</code> and comparing with the result for the regular <code>cos</code> function:</p><pre><code class="language-julia hljs">myderiv   = autodiff(Forward, mycos, Duplicated(2.0f0, 1.2f0))[1] # -1.091157f0
truederiv = autodiff(Forward, cos, Duplicated(2.0f0, 1.2f0))[1] # -1.091157f0
@assert myderiv = truederiv</code></pre><p>For more information about easy rules, see the <a href="../#man-easy-rule">manual</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L678-L755">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules._constrain_and_name-Tuple{Expr}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules._constrain_and_name-Tuple{Expr}"><code>EnzymeCore.EnzymeRules._constrain_and_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_constrain_and_name(arg::Expr, _)</code></pre><p>Internal function.</p><p>Turn both <code>a</code> and <code>::constraint</code> into <code>a::Annotation{&lt;:constraint}</code> etc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L60-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules._just_name-Tuple{Expr}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules._just_name-Tuple{Expr}"><code>EnzymeCore.EnzymeRules._just_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_just_name(arg::Expr, _)</code></pre><p>Internal function.</p><p>Extract <code>a</code> from <code>a::constraint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L77-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules._normalize_scalarrules_macro_input-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules._normalize_scalarrules_macro_input-Tuple{Any, Any, Any}"><code>EnzymeCore.EnzymeRules._normalize_scalarrules_macro_input</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_normalize_scalarrules_macro_input(call, maybe_setup, partials)</code></pre><p>Internal function.</p><p>returns (in order) the correctly escaped:</p><ul><li><code>call</code> with out any type constraints</li><li><code>setup_stmts</code>: the content of <code>@setup</code> or <code>[]</code> if that is not provided,</li><li><code>inputs</code>: with all args having the constraints removed from call, or   defaulting to <code>Number</code></li><li><code>partials</code>: which are all <code>Expr{:tuple,...}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L111-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules._unconstrain-Tuple{Symbol}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules._unconstrain-Tuple{Symbol}"><code>EnzymeCore.EnzymeRules._unconstrain</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unconstrain(a)</code></pre><p>Internal function.</p><p>Turn both <code>a</code> and <code>a::S</code> into <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L45-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.augmented_primal"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.augmented_primal"><code>EnzymeCore.EnzymeRules.augmented_primal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">augmented_primal(::RevConfig, func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Code to run during the original forward pass through the code. Any additional data can be saved from forward to reverse pass. This may be required as arguments might be overwritten before the reverse pass is run.</p><p>This should compute and mutate the same values as the original function (if requested).</p><p>It should also return a shadow data structure to hold derivatives (if requested).</p><p>Must return an <a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>AugmentedReturn</code></a> type.</p><ul><li>The primal must be the same type of the original return if <a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>needs_primal(config)</code></a>, otherwise nothing.</li><li>The shadow must be nothing if <a href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>needs_shadow(config)</code></a> is <code>false</code>. If width is 1, the shadow should be the same type of the original return. If the width is greater than 1, the shadow should be <code>NTuple{original return, width}</code>.</li><li>The tape can be any type (including <code>Nothing</code>), and is preserved for the reverse call.</li></ul><p>See <a href="#EnzymeCore.EnzymeRules.augmented_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.RevConfig}, Type{&lt;:Annotation}}"><code>augmented_rule_return_type</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L243-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.augmented_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.RevConfig}, Type{&lt;:Annotation}}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.augmented_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.RevConfig}, Type{&lt;:Annotation}}"><code>EnzymeCore.EnzymeRules.augmented_rule_return_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">augmented_rule_return_type(C::RevConfig, RT::Type{&lt;:Annotation}, cache::Any)
augmented_rule_return_type(::Type{&lt;:RevConfig}, RT::Type{&lt;:Annotation}, CacheType::Type)
augmented_rule_return_type(C::RevConfig, RT::Type{&lt;:Annotation})
augmented_rule_return_type(::Type{&lt;:RevConfig}, RT::Type{&lt;:Annotation})</code></pre><p>Compute the expected result type of a custom augmented forward pass rule, given the configuration <code>C</code> return activity and type <code>RT</code>, and cache <code>cache</code>. Alternatively, this can be called with the configuration type, return activity, and cache type.</p><p>Consider <code>RealRt</code> as the original return type of the rule, accessible as <code>eltype(RT)</code>. The return type can be computed as follows:</p><p>We must return a struct of type <a href="#EnzymeCore.EnzymeRules.AugmentedReturn"><code>AugmentedReturn</code></a>, which has three elements (and corresponding type parameter).</p><p>The first element is the primal type, which is the original result (of type <code>RealRt</code>) if requested by the config (<a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>needs_primal</code></a>), otherwise nothing.</p><p>The second element is the shadow type, if requested by the config (<a href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>needs_shadow</code></a>, otherwise nothing. If requested, the shadow is of type:     If the <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a> is one, the shadow is the same type as the primal (<code>RealRt</code>).     If the <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a> is not one, the shadow is a tuple containing <code>width</code> of the original return types (<code>NTuple{width,RealRt}</code>).</p><p>The third element is user defined, whatever type the cache is you want to save from forward to reverse pass. In this case, it will be determined by <code>cache</code>, or <code>CacheType</code>.</p><p>If a cache type is not provided a unionall will be returned</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L276-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.forward"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.forward"><code>EnzymeCore.EnzymeRules.forward</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forward(fwdconfig, func::Annotation{typeof(f)}, RT::Type{&lt;:Annotation}, args::Annotation...)</code></pre><p>Calculate the forward derivative. The first argument is a <a href="#EnzymeCore.EnzymeRules.FwdConfig"><code>FwdConfig</code></a> object describing parameters of the differentiation. The second argument <code>func</code> is the callable to which the rule applies, either wrapped in a <a href="#EnzymeCore.Const"><code>Const</code></a>), or a <a href="#EnzymeCore.Duplicated"><code>Duplicated</code></a> if it is a closure. The third argument is the return type annotation, and all other arguments are the annotated arguments to the function <code>f</code>.</p><p>Valid types for <code>RT</code> are:</p><ul><li><a href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a></li><li><a href="#EnzymeCore.DuplicatedNoNeed"><code>EnzymeCore.DuplicatedNoNeed</code></a></li><li><a href="#EnzymeCore.Const"><code>EnzymeCore.Const</code></a></li></ul><p>The return from this function must be a type matching <a href="#EnzymeCore.EnzymeRules.forward_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.FwdConfig}, Type{&lt;:Annotation}}"><code>forward_rule_return_type</code></a> when given the <code>fwdconfig</code> and <code>RT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L14-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.forward_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.FwdConfig}, Type{&lt;:Annotation}}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.forward_rule_return_type-Tuple{Type{&lt;:EnzymeCore.EnzymeRules.FwdConfig}, Type{&lt;:Annotation}}"><code>EnzymeCore.EnzymeRules.forward_rule_return_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forward_rule_return_type(C::FwdConfig, RT::Type{&lt;:Annotation})
forward_rule_return_type(::Type{&lt;:FwdConfig}, RT::Type{&lt;:Annotation})</code></pre><p>Compute the expected result type of a custom forward rule, given the configuration <code>C</code> and return activity and type <code>RT</code>.</p><p>Consider <code>RealRt</code> as the original return type of the rule, accessible as <code>eltype(RT)</code>. The return type can be computed as follows:</p><p>If the shadow isn&#39;t needed, return the original result (of type <code>RealRt</code>) if requested by the config (<a href="#EnzymeCore.needs_primal-Union{Tuple{ReverseMode{ReturnPrimal}}, Tuple{ReturnPrimal}} where ReturnPrimal"><code>needs_primal</code></a>), otherwise nothing.</p><p>Otherwise, first construct a shadow return.     If the <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a> is one, the shadow is the same type as the primal (<code>RealRt</code>).     If the <a href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>width</code></a> is not one, the shadow is a tuple containing <code>width</code> of the original return types (<code>NTuple{width,RealRt}</code>).</p><p>Finally, if both the primal and shadow are requested, return a <a href="#EnzymeCore.Duplicated"><code>EnzymeCore.Duplicated</code></a> or <a href="#EnzymeCore.BatchDuplicated"><code>EnzymeCore.BatchDuplicated</code></a> of primal and shadows. Otherwise, just return the shadows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L153-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.inactive"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.inactive"><code>EnzymeCore.EnzymeRules.inactive</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inactive(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L426-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.inactive_arg"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.inactive_arg"><code>EnzymeCore.EnzymeRules.inactive_arg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inactive_arg(func::typeof(f), args...; kwargs...)</code></pre><p>Mark a particular function as always having inactive non-keyword arguments. The return type must be a tuple of Val&#39;s whose value is the argument marked inactive.</p><p>This function is currently considered internal/experimental and may not respect semver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L471-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.inactive_kwarg"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.inactive_kwarg"><code>EnzymeCore.EnzymeRules.inactive_kwarg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inactive_kwarg(func::typeof(f), args...; kwargs...)</code></pre><p>Mark a particular function as always having inactive keyword arguments. The return does not matter, merely its declaration.</p><p>This function is currently considered internal/experimental and may not respect semver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L455-L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.inactive_noinl"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.inactive_noinl"><code>EnzymeCore.EnzymeRules.inactive_noinl</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inactive_noinl(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being inactive in both its return result and the function call itself, but do not prevent inlining of the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L440-L445">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.inactive_type-Tuple{Type}"><code>EnzymeCore.EnzymeRules.inactive_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inactive_type(::Type{Ty})</code></pre><p>Mark a particular type <code>Ty</code> as always being inactive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L503-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.multiply_fwd_into"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.multiply_fwd_into"><code>EnzymeCore.EnzymeRules.multiply_fwd_into</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multiply_fwd_into(prev, partial, dx)</code></pre><p>Internal function.</p><p>Multiply a partial derivative (df/dx) by its shadow input (dx) to form <code>df</code>.</p><p>Specifically, perform prev + partial * dx, returning the result or re-using prev&#39;s memory, where applicable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L89-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.multiply_rev_into"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.multiply_rev_into"><code>EnzymeCore.EnzymeRules.multiply_rev_into</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">multiply_rev_into(prev, partial, df)</code></pre><p>Internal function.</p><p>Multiply a partial derivative (df/dx) by its shadow input (df) to form <code>dx</code>.</p><p>Specifically, perform prev + conj(partial * conj(dx)), returning the result or re-using prev&#39;s memory, where applicable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L100-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.needs_shadow-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, var&quot;#s9&quot;, NeedsShadow} where {var&quot;#s9&quot;, Width}}, Tuple{NeedsShadow}} where NeedsShadow"><code>EnzymeCore.EnzymeRules.needs_shadow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">needs_shadow(::FwdConfig)
needs_shadow(::RevConfig)
needs_shadow(::Type{&lt;:FwdConfig})
needs_shadow(::Type{&lt;:RevConfig})</code></pre><p>Whether a custom rule should return the shadow (derivative) of the function result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L60-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.noalias"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.noalias"><code>EnzymeCore.EnzymeRules.noalias</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">noalias(func::typeof(f), args...)</code></pre><p>Mark a particular function as always being a fresh allocation which does not alias any other accessible memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L488-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.overwritten-Union{Tuple{EnzymeCore.EnzymeRules.RevConfigWidth{&lt;:Any, var&quot;#s7&quot;, var&quot;#s3&quot;, Overwritten} where {var&quot;#s7&quot;, var&quot;#s3&quot;}}, Tuple{Overwritten}} where Overwritten"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.overwritten-Union{Tuple{EnzymeCore.EnzymeRules.RevConfigWidth{&lt;:Any, var&quot;#s7&quot;, var&quot;#s3&quot;, Overwritten} where {var&quot;#s7&quot;, var&quot;#s3&quot;}}, Tuple{Overwritten}} where Overwritten"><code>EnzymeCore.EnzymeRules.overwritten</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">overwritten(::RevConfig)
overwritten(::Type{&lt;:RevConfig})</code></pre><p>A tuple of booleans for each argument (including the function itself), indicating if it is modified between the forward and reverse pass (<code>true</code> if potentially modified between).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L112-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.primal_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.primal_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><code>EnzymeCore.EnzymeRules.primal_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">primal_type(::FwdConfig, ::Type{&lt;:Annotation{RT}})
primal_type(::RevConfig, ::Type{&lt;:Annotation{RT}})
primal_type(::Type{&lt;:FwdConfig}, ::Type{&lt;:Annotation{RT}})
primal_type(::Type{&lt;:RevConfig}, ::Type{&lt;:Annotation{RT}})</code></pre><p>Compute the expected primal return type given a reverse mode config and return activity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L126-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.reverse"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.reverse"><code>EnzymeCore.EnzymeRules.reverse</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reverse(::RevConfig, func::Annotation{typeof(f)}, dret::Active, tape, args::Annotation...)
reverse(::RevConfig, func::Annotation{typeof(f)}, ::Type{&lt;:Annotation), tape, args::Annotation...)</code></pre><p>Takes gradient of derivative, activity annotation, and tape. If there is an active return, <code>dret</code> is passed as <code>Active{T}</code> with the derivative of the active return value. Otherwise, <code>dret</code> is passed as <code>Type{Duplicated{T}}</code>, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L265-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.shadow_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.shadow_type-Union{Tuple{RT}, Tuple{EnzymeCore.EnzymeRules.FwdConfig, Type{&lt;:Annotation{RT}}}} where RT"><code>EnzymeCore.EnzymeRules.shadow_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">shadow_type(::FwdConfig, ::Type{&lt;:Annotation{RT}})
shadow_type(::RevConfig, ::Type{&lt;:Annotation{RT}})
shadow_type(::Type{&lt;:FwdConfig}, ::Type{&lt;:Annotation{RT}})
shadow_type(::Type{&lt;:RevConfig}, ::Type{&lt;:Annotation{RT}})</code></pre><p>Compute the expected shadow return type given a reverse mode config and return activity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L139-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.uses_symbol-Tuple{Any, Symbol}"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.uses_symbol-Tuple{Any, Symbol}"><code>EnzymeCore.EnzymeRules.uses_symbol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uses_symbol(a, b::Symbol)</code></pre><p>Internal function.</p><p>Checks if <code>a</code> contains a use of the symbol <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/easyrules.jl#L20-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><a class="docstring-binding" href="#EnzymeCore.EnzymeRules.width-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width}}, Tuple{Width}} where Width"><code>EnzymeCore.EnzymeRules.width</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">width(::FwdConfig)
width(::RevConfig)
width(::Type{&lt;:FwdConfig})
width(::Type{&lt;:RevConfig})</code></pre><p>Get the size of a batch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L72-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeCore.needs_primal-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, NeedsPrimal, NeedsShadow} where {NeedsShadow, Width}}, Tuple{NeedsPrimal}} where NeedsPrimal"><a class="docstring-binding" href="#EnzymeCore.needs_primal-Union{Tuple{EnzymeCore.EnzymeRules.FwdConfigWidth{Width, NeedsPrimal, NeedsShadow} where {NeedsShadow, Width}}, Tuple{NeedsPrimal}} where NeedsPrimal"><code>EnzymeCore.needs_primal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">needs_primal(::FwdConfig)
needs_primal(::RevConfig)
needs_primal(::Type{&lt;:FwdConfig})
needs_primal(::Type{&lt;:RevConfig})</code></pre><p>Whether a custom rule should return the original result of the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeCore/src/rules.jl#L49-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeTestUtils.ExprAndMsg"><a class="docstring-binding" href="#EnzymeTestUtils.ExprAndMsg"><code>EnzymeTestUtils.ExprAndMsg</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A cunning hack to carry extra message along with the original expression in a test</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeTestUtils/src/output_control.jl#L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#EnzymeTestUtils.@test_msg-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.@test_msg</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@test_msg msg condition kws...</code></pre><p>This is per <code>Test.@test condition kws...</code>, except that if it fails it also prints the <code>msg</code>. If <code>msg==&quot;&quot;</code> then this is just like <code>@test</code>, nothing is printed.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @test_msg &quot;It is required that the total is under 10&quot; sum(1:1000) &lt; 10;
Test Failed at REPL[1]:1
  Expression: sum(1:1000) &lt; 10
  Problem: It is required that the total is under 10
   Evaluated: 500500 &lt; 10
ERROR: There was an error during testing


julia&gt; @test_msg &quot;It is required that the total is under 10&quot; error(&quot;not working at all&quot;);
Error During Test at REPL[2]:1
  Test threw exception
  Expression: error(&quot;not working at all&quot;)
  Problem: It is required that the total is under 10
  &quot;not working at all&quot;
  Stacktrace:

julia&gt; a = &quot;&quot;;

julia&gt; @test_msg a sum(1:1000) &lt; 10;
  Test Failed at REPL[153]:1
    Expression: sum(1:1000) &lt; 10
     Evaluated: 500500 &lt; 10
  ERROR: There was an error during testing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeTestUtils/src/output_control.jl#L14-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#EnzymeTestUtils.are_activities_compatible-Tuple{Any, Vararg{Any}}"><code>EnzymeTestUtils.are_activities_compatible</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">are_activities_compatible(Tret, activities...) -&gt; Bool</code></pre><p>Return <code>true</code> if return activity type <code>Tret</code> and activity types <code>activities</code> are compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeTestUtils/src/compatible_activities.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#EnzymeTestUtils.test_forward-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_forward</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_forward(f, Activity, args...; kwargs...)</code></pre><p>Test <code>Enzyme.autodiff</code> of <code>f</code> in <code>Forward</code>-mode against finite differences.</p><p><code>f</code> has all constraints of the same argument passed to <code>Enzyme.autodiff</code>, with additional constraints:</p><ul><li>If it mutates one of its arguments, it <em>must</em> return that argument.</li></ul><p><strong>Arguments</strong></p><ul><li><code>Activity</code>: the activity of the return value of <code>f</code></li><li><code>args</code>: Each entry is either an argument to <code>f</code>, an activity type accepted by <code>autodiff</code>,   or a tuple of the form <code>(arg, Activity)</code>, where <code>Activity</code> is the activity type of   <code>arg</code>. If the activity type specified requires a tangent, a random tangent will be   automatically generated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rng::AbstractRNG</code>: The random number generator to use for generating random tangents.</li><li><code>fdm=FiniteDifferences.central_fdm(5, 1)</code>: The finite differences method to use.</li><li><code>fkwargs</code>: Keyword arguments to pass to <code>f</code>.</li><li><code>rtol</code>: Relative tolerance for <code>isapprox</code>.</li><li><code>atol</code>: Absolute tolerance for <code>isapprox</code>.</li><li><code>testset_name</code>: Name to use for a testset in which all tests are evaluated.</li></ul><p><strong>Examples</strong></p><p>Here we test a rule for a function of scalars. Because we don&#39;t provide an activity annotation for <code>y</code>, it is assumed to be <code>Const</code>.</p><pre><code class="language-julia hljs">using Enzyme, EnzymeTestUtils

x, y = randn(2)
for Tret in (Const, Duplicated, DuplicatedNoNeed), Tx in (Const, Duplicated)
    test_forward(*, Tret, (x, Tx), y)
end</code></pre><p>Here we test a rule for a function of an array in batch forward-mode:</p><pre><code class="language-julia hljs">x = randn(3)
y = randn()
for Tret in (Const, BatchDuplicated, BatchDuplicatedNoNeed),
    Tx in (Const, BatchDuplicated),
    Ty in (Const, BatchDuplicated)

    test_forward(*, Tret, (x, Tx), (y, Ty))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeTestUtils/src/test_forward.jl#L1-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#EnzymeTestUtils.test_reverse-Tuple{Any, Any, Vararg{Any}}"><code>EnzymeTestUtils.test_reverse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_reverse(f, Activity, args...; kwargs...)</code></pre><p>Test <code>Enzyme.autodiff_thunk</code> of <code>f</code> in <code>ReverseSplitWithPrimal</code>-mode against finite differences.</p><p><code>f</code> has all constraints of the same argument passed to <code>Enzyme.autodiff_thunk</code>, with additional constraints:</p><ul><li>If an <code>Array{&lt;:AbstractFloat}</code> appears in the input/output, then a reshaped version of it   may not also appear in the input/output.</li></ul><p><strong>Arguments</strong></p><ul><li><code>Activity</code>: the activity of the return value of <code>f</code>.</li><li><code>args</code>: Each entry is either an argument to <code>f</code>, an activity type accepted by <code>autodiff</code>,   or a tuple of the form <code>(arg, Activity)</code>, where <code>Activity</code> is the activity type of   <code>arg</code>. If the activity type specified requires a shadow, one will be automatically   generated.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rng::AbstractRNG</code>: The random number generator to use for generating random tangents.</li><li><code>fdm=FiniteDifferences.central_fdm(5, 1)</code>: The finite differences method to use.</li><li><code>fkwargs</code>: Keyword arguments to pass to <code>f</code>.</li><li><code>rtol</code>: Relative tolerance for <code>isapprox</code>.</li><li><code>atol</code>: Absolute tolerance for <code>isapprox</code>.</li><li><code>testset_name</code>: Name to use for a testset in which all tests are evaluated.</li><li><code>output_tangent</code>: Optional final tangent to provide at the beginning of the reverse-mode differentiation </li></ul><p><strong>Examples</strong></p><p>Here we test a rule for a function of scalars. Because we don&#39;t provide an activity annotation for <code>y</code>, it is assumed to be <code>Const</code>.</p><pre><code class="language-julia hljs">using Enzyme, EnzymeTestUtils

x = randn()
y = randn()
for Tret in (Const, Active), Tx in (Const, Active)
    test_reverse(*, Tret, (x, Tx), y)
end</code></pre><p>Here we test a rule for a function of an array in batch reverse-mode:</p><pre><code class="language-julia hljs">x = randn(3)
for Tret in (Const, Active), Tx in (Const, BatchDuplicated)
    test_reverse(prod, Tret, (x, Tx))
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/lib/EnzymeTestUtils/src/test_reverse.jl#L15-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.fast_math!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.fast_math!-Tuple{Any}"><code>Enzyme.API.fast_math!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fast_math!(val::Bool)</code></pre><p>Whether generated derivatives have fast math on or off, default on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1260-L1264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.inlineall!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.inlineall!-Tuple{Any}"><code>Enzyme.API.inlineall!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inlineall!(val::Bool)</code></pre><p>Whether to inline all (non-recursive) functions generated by Julia within a  single compilation unit. This may improve Enzyme&#39;s ability to successfully differentiate code and improve performance of the original and generated  derivative program. It often, however, comes with an increase in compile time. This is off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1172-L1180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.instname!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.instname!-Tuple{Any}"><code>Enzyme.API.instname!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">instname!(val::Bool)</code></pre><p>Whether to add a name to all LLVM values. This may be helpful for debugging generated programs, both primal and derivative. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1283-L1289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>Enzyme.API.looseTypeAnalysis!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">looseTypeAnalysis!(val::Bool)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. For example, a copy of Float32&#39;s requires a different derivative than a memcpy of Float64&#39;s, Ptr&#39;s, etc. In some cases Enzyme may not be able to deduce all the types necessary and throw an unknown type error. If this is the case, open an issue.  One can silence these issues by setting <code>looseTypeAnalysis!(true)</code> which tells  Enzyme to make its best guess. This will remove the error and allow differentiation to continue, however, it may produce incorrect results. Alternatively one can consider increasing the space of the evaluated type lattice which gives Enzyme more time to run a more thorough analysis through the use of <a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>maxtypeoffset!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1223-L1236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.maxtypedepth!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.maxtypedepth!-Tuple{Any}"><code>Enzyme.API.maxtypedepth!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxtypedepth!(val::Int)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. To ensure this analysis temrinates, it operates on a finite lattice of possible states. This function sets the maximum depth into a type that Enzyme will consider. A smaller value will cause type analysis to run faster, but may result in some necessary types not being found and result in unknown type errors. A larger value may result in unknown type errors being resolved by searching a larger space, but may run longer. The default setting is 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1204-L1215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.maxtypeoffset!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>Enzyme.API.maxtypeoffset!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maxtypeoffset!(val::Int)</code></pre><p>Enzyme runs a type analysis to deduce the corresponding types of all values being differentiated. This is necessary to compute correct derivatives of various values. To ensure this analysis temrinates, it operates on a finite lattice of possible states. This function sets the maximum offset into a type that Enzyme will consider. A smaller value will cause type analysis to run faster, but may result in some necessary types not being found and result in unknown type errors. A larger value may result in unknown type errors being resolved by searching a larger space, but may run longer. The default setting is 512.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1187-L1198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.memmove_warning!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.memmove_warning!-Tuple{Any}"><code>Enzyme.API.memmove_warning!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">memmove_warning!(val::Bool)</code></pre><p>Whether to issue a warning when differentiating memmove. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1295-L1300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printactivity!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printactivity!-Tuple{Any}"><code>Enzyme.API.printactivity!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printactivity!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) a log of all decisions made during Activity Analysis (the analysis which determines what values/instructions are differentiated). This may be useful for debugging MixedActivity errors, correctness, and performance errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1124-L1133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printall!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printall!-Tuple{Any}"><code>Enzyme.API.printall!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printall!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) the LLVM function being differentiated, as well as all generated derivatives immediately after running Enzyme (but prior to any other optimizations). Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1139-L1147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printdiffuse!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>Enzyme.API.printdiffuse!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printdiffuse!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) information about each LLVM value – specifically whether it and its shadow is required for computing the derivative. In contrast to <a href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>printunnecessary!</code></a>, this flag prints debug log for the analysis which determines for each value and shadow value, whether it can find a user which would require it to be kept around (rather than being deleted). This is prior to any cache optimizations and a debug log of Differential Use Analysis. This may be helpful for debugging caching, phi node deletion, performance, and other errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1089-L1102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printperf!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printperf!-Tuple{Any}"><code>Enzyme.API.printperf!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printperf!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) performance information about generated derivative programs. It will provide debug information that warns why particular values are cached for the reverse pass, and thus require additional computation/storage. This is particularly helpful for debugging derivatives which OOM or otherwise run slow. ff by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1073-L1083">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printtype!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printtype!-Tuple{Any}"><code>Enzyme.API.printtype!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printtype!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) a log of all decisions made during Type Analysis (the analysis which Enzyme determines the type of all values in the program). This may be useful for debugging correctness errors, illegal type analysis errors, insufficient type information errors, correctness, and performance errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1108-L1118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.printunnecessary!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.printunnecessary!-Tuple{Any}"><code>Enzyme.API.printunnecessary!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">printunnecessary!(val::Bool)</code></pre><p>An debugging option for developers of Enzyme. If one sets this flag prior to the first differentiation of a function, Enzyme will print (to stderr) information about each LLVM value – specifically whether it and its shadow is required for computing the derivative. In contrast to <a href="#Enzyme.API.printdiffuse!-Tuple{Any}"><code>printdiffuse!</code></a>, this flag prints the final results after running cache optimizations such as minCut (see Recompute vs Cache Heuristics from <a href="https://c.wsmoses.com/papers/EnzymeGPU.pdf">this paper</a> and slides 31-33 from <a href="https://c.wsmoses.com/presentations/enzyme-sc.pdf">this presentation</a>) for a description of the caching algorithm. This may be helpful for debugging caching, phi node deletion, performance, and other errors. Off by default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1153-L1166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.strictAliasing!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.strictAliasing!-Tuple{Any}"><code>Enzyme.API.strictAliasing!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">strictAliasing!(val::Bool)</code></pre><p>Whether Enzyme&#39;s type analysis will assume strict aliasing semantics. When strict aliasing semantics are on (the default), Enzyme can propagate type information up through conditional branches. This may lead to illegal type errors when analyzing code with unions. Disabling strict aliasing will enable these union types to be correctly analyzed. However, it may lead to some errors that sufficient type information cannot be deduced. One can turn these insufficient type information errors into to warnings by calling <a href="#Enzyme.API.looseTypeAnalysis!-Tuple{Any}"><code>looseTypeAnalysis!</code></a><code>(true)</code> which tells Enzyme to use its best guess in such scenarios.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1243-L1254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.API.typeWarning!-Tuple{Any}"><a class="docstring-binding" href="#Enzyme.API.typeWarning!-Tuple{Any}"><code>Enzyme.API.typeWarning!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">typeWarning!(val::Bool)</code></pre><p>Whether to print a warning when Type Analysis learns informatoin about a value&#39;s type which cannot be represented in the current size of the lattice. See <a href="#Enzyme.API.maxtypeoffset!-Tuple{Any}"><code>maxtypeoffset!</code></a> for more information. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/api.jl#L1270-L1277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Enzyme.Compiler.CheckNan"><a class="docstring-binding" href="#Enzyme.Compiler.CheckNan"><code>Enzyme.Compiler.CheckNan</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">CheckNan::Ref{Bool}</code></pre><p>If <code>Enzyme.Compiler.CheckNan[] == true</code>, Enzyme will error at the first encounter of a <code>NaN</code> during differentiation. Useful as a debugging tool to help locate the call whose derivative is the source of unexpected <code>NaN</code>s. Off by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/EnzymeAD/Enzyme.jl/blob/6ec1a536925120f5854e0fd553b01dacbec5eb71/src/compiler.jl#L1386-L1392">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« FAQ</a><a class="docs-footer-nextpage" href="../dev_docs/">For developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 18 January 2026 23:06">Sunday 18 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
